#include "NcFileExtended.h"
#include <boost/algorithm/string.hpp>
#include <boost/algorithm/string/split.hpp>
#include <macgyver/Exception.h>
#include <macgyver/NumericCast.h>
#include <macgyver/StringConversion.h>
#include <macgyver/TimeParser.h>
#include <macgyver/TypeTraits.h>
#include <newbase/NFmiFastQueryInfo.h>
#include <iostream>
#include <memory>
#include <string>
#include <type_traits>
#include <ncException.h>

using netCDF::NcDim;
using netCDF::NcGroupAtt;
using netCDF::NcVar;
using netCDF::NcVarAtt;
using netCDF::NcType;

using namespace std::literals;

namespace
{

netCDF::NcVarAtt ncvar_get_attr(const netCDF::NcVar& var, const char *name, bool silent)
try
{
  return var.getAtt(name);
}
catch (const netCDF::exceptions::NcException&)
{
  if (!silent)
    std::cout << "NetCDF: attribute '" << name << "' not found" << std::endl;
  return netCDF::NcVarAtt();
}
catch (...)
{
  throw Fmi::Exception::Trace(BCP, "Operation failed!");
}

}  // anonymous namespace

std::string nctools::get_att_string_value(const netCDF::NcAtt& att)
{
  try
  {
    using netCDF::NcType;

    const netCDF::NcType type = att.getType();

    if (type == NcType::nc_BYTE || type == NcType::nc_CHAR)
    {
      std::vector<char> bytes(att.getAttLength());
      att.getValues(bytes.data());
      const std::string result = std::string(bytes.data(), bytes.size());
      return result;
    }
    else if (type == NcType::nc_FLOAT or type == NcType::nc_DOUBLE)
    {
      std::vector<double> values(att.getAttLength());
      att.getValues(values.data());
      return Fmi::to_string(values.at(0));
    }
    else if (type == NcType::nc_SHORT or type == NcType::nc_INT or type == NcType::nc_INT64)
    {
      std::vector<int64_t> values(att.getAttLength());
      att.getValues(values.data());
      return Fmi::to_string(values.at(0));
    }
    else if (type == NcType::nc_USHORT or type == NcType::nc_UINT or type == NcType::nc_UINT64)
    {
      std::vector<uint64_t> values(att.getAttLength());
      att.getValues(values.data());
      return Fmi::to_string(values.at(0));
    }
    else
    {
      throw Fmi::Exception(BCP, "FIXME: implementation missing");
    }
  }
  catch (...)
  {
    auto error = Fmi::Exception::Trace(BCP, "Operation failed!");
    error.addParameter("Attribute name", att.getName());
    error.addParameter("Attribute type", att.getType().getName());
    error.addParameter("Attribute length", std::to_string(att.getAttLength()));
    throw error;
  }
}

// ----------------------------------------------------------------------
/*!
 * \brief Extract NetCDF parameter name
 */
// ----------------------------------------------------------------------

std::string nctools::get_name(const NcVar& var)
{
  try
  {
    //NcError netcdf_error_handling(NcError::silent_nonfatal);
    NcVarAtt att = ncvar_get_attr(var, "standard_name", true);
    if (att.isNull())
      return var.getName();

    const NcType type = att.getType();
    if (type != NcType::nc_BYTE && type != NcType::nc_CHAR)
      throw std::runtime_error("The standard_name attribute must be a string for variable " +
                               std::string(var.getName()));

    return nctools::get_att_string_value(att);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Parse parameter id
 */
// ----------------------------------------------------------------------

nctools::ParamInfo parse_parameter(const NcVar& var, const nctools::ParamConversions &paramconvs, bool useAutoGeneratedIds)
{
  try
  {
    const auto numDims = var.getDimCount();
    if (numDims < 3 || numDims > 4)
      return nctools::ParamInfo();

    return nctools::parse_parameter(nctools::get_name(var), paramconvs, useAutoGeneratedIds);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * \brief Find variable with given name
 */
// ----------------------------------------------------------------------

NcVar nctools::NcFileExtended::find_variable(const std::string &name)
{
  try
  {
    return this->getVar(name);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * \brief Get the missing value
 */
// ----------------------------------------------------------------------

float nctools::NcFileExtended::get_missingvalue(const NcVar& var) const
{
  try
  {
    if (!wrf)
    {
      NcVarAtt att = ncvar_get_attr(var, "_FillValue", true);
      if (!att.isNull())
      {
        return nctools::get_att_value<float>(att, 0);
      }
      // Fillvalue can be also fill_value
      att = ncvar_get_attr(var, "fill_value", false);
      if (!att.isNull())
        return nctools::get_att_value<float>(att, 0);

      return std::numeric_limits<float>::quiet_NaN();
    }

    return std::numeric_limits<float>::quiet_NaN();
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * \brief Get the scale value
 */
// ----------------------------------------------------------------------

float nctools::get_scale(const NcVar& var)
{
  try
  {
    const NcVarAtt att = ncvar_get_attr(var, "scale_factor", true);
    if (!att.isNull())
      return nctools::get_att_value<float>(att, 0);
    else
      return 1.0f;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * \brief Get the offset value
 */
// ----------------------------------------------------------------------

float nctools::get_offset(const NcVar& var)
{
  try
  {
    const NcVarAtt att = ncvar_get_attr(var, "add_offset", true);
    if (!att.isNull())
      return nctools::get_att_value<float>(att, 0);
    else
      return 0.0f;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Report unit conversions if they are done
 */
// ----------------------------------------------------------------------

void nctools::report_units(const NcVar& var,
                  const std::string &units,
                  const nctools::Options &options,
                  bool ignoreUnitChange)
{
  try
  {
    if (!options.verbose)
      return;

    if (units == "K")
    {
      if (ignoreUnitChange)
        std::cout << "Note: " << nctools::get_name(var) << " units convertion ignored from K to C"
                  << std::endl;
      else
        std::cout << "Note: " << nctools::get_name(var) << " units converted from K to C" << std::endl;
    }
    else if (units == "Pa")
    {
      if (ignoreUnitChange)
        std::cout << "Note: " << nctools::get_name(var) << " units convertion ignored from pa to hPa"
                  << std::endl;
      else
        std::cout << "Note: " << nctools::get_name(var) << " units converted from pa to hPa" << std::endl;
    }
    else if (units == "fraction")
    {
      if (ignoreUnitChange)
        std::cout << "Note: " << nctools::get_name(var)
                  << " units convertion ignored from fraction to percentage" << std::endl;
      else
        std::cout << "Note: " << nctools::get_name(var) << " units converted from fraction to percentage"
                  << std::endl;
    }
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

bool IsMissingValue(float value, float ncMissingValue)
{
  try
  {
    const float extraMissingValueLimit =
        9.99e034f;  // joskus datassa on outoja isoja (ja
                    // vaihtelevia) lukuja esim. vuoriston kohdalla,
    // jotka pitää mielestäni tulkita puuttuviksi (en tiedä mitä muutakaan voi tehdä)
    if (value != ncMissingValue && value < extraMissingValueLimit)
      return false;
    else
      return true;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

bool nctools::is_name_in_list(const std::list<std::string> &nameList, const std::string name)
{
  try
  {
    if (!nameList.empty())
    {
      std::list<std::string>::const_iterator it = std::find(nameList.begin(), nameList.end(), name);
      if (it != nameList.end())
        return true;
    }
    return false;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Copy raw NetCDF data into querydata
 */
// ----------------------------------------------------------------------

void nctools::NcFileExtended::copy_values(const Options &options,
                                 NFmiFastQueryInfo &info,
                                 const ParamConversions &paramconvs,
                                 bool useAutoGeneratedIds)
{
  try
  {
    const std::multimap<std::string,NcVar> vars = getVars();
    if (vars.empty())
      return;

    for (const auto& item : vars)
    {
      const NcVar& var = item.second;
      if (var.isNull())
        continue;

      if (!wrf)
      {
        if (!axis_match(var) && options.verbose)
          std::cerr << "warning: no matching axis for " << var.getName() << "\n";
        continue;
      }

      ParamInfo pinfo = nctools::parse_parameter(nctools::get_name(var), paramconvs, useAutoGeneratedIds);
      if (pinfo.id == kFmiBadParameter)
        continue;

      if (info.Param(pinfo.id))
      {
        // Now we handle differently the two cases of a regular parameter
        // and one calculated from X- and Y-components

        if (pinfo.isregular)
          copy_values(options, var, info);
        else
          copy_values(info, pinfo, &options);
      }
    }
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Copy regular variable data into querydata
 */
// ----------------------------------------------------------------------

void nctools::NcFileExtended::copy_values(const Options &options, const NcVar& var, NFmiFastQueryInfo &info)
{
  try
  {
    std::string name = var.getName();

    if (options.debug)
      std::cerr << "\ndebug: starting copy for variable " << name << std::endl;

    std::string units = "";
    const NcVarAtt att = ncvar_get_attr(var, "units", true);
    if (!att.isNull())
      units = nctools::get_att_string_value(att);

    // joskus metatiedot valehtelevat, tällöin ei saa muuttaa parametrin yksiköitä
    bool ignoreUnitChange = is_name_in_list(options.ignoreUnitChangeParams, name);

    nctools::report_units(var, units, options);

    float missingvalue = get_missingvalue(var);
    float scale = get_scale(var);
    float offset = get_offset(var);

    // Apply unit conversion outside the loop for speed
    if (!ignoreUnitChange)
    {
      if (units == "K")
        offset -= 273.15;
      else if (units == "Pa")
        scale *= 0.01;
      else if (units == "fraction")
        scale *= 100;
    }

    // NetCDF data ordering: time, level, rows from bottom row to top row, left-right order in row,
    // if none of the axises are inverted We have to calculate the actual position for inverted
    // axises. They will be non-inverted in the result data.
    int sourcetimeindex = 0;
    int targettimeindex = 0;

    const std::vector<float> vals = nctools::get_values<float>(var);

    unsigned long zstart = 0;

    for (info.ResetTime(); info.NextTime(); ++targettimeindex)
    {
      unsigned long level = 0;

      // Only copy to correct time index
      NFmiTime targettime = info.Time();

      auto tmp_tlist = timeList();
      const NFmiTime *sourcetimeptr = tmp_tlist.Time(sourcetimeindex);

      if (options.debug)
        std::cerr << "debug: targettimeindex=" << targettimeindex << " targettime=" << targettime
                  << " sourcetimeindex= " << sourcetimeindex << " sourcetimeptr=" << sourcetimeptr
                  << std::endl;

      // Skip to next targettimeindex or drop out(to next file possibly) if source does not have
      // this index at all (we are at end of source times?)
      if (sourcetimeptr == nullptr)
      {
        if (options.debug)
          std::cerr << "debug: source has no more times, skipping rest of target indexes"
                    << std::endl;
        break;  // Pointless to go through the rest of list, there are none
      }

      NFmiTime sourcetime = *sourcetimeptr;
      if (options.debug)
        std::cerr << "debug: sourcetime=" << sourcetime << std::endl;

      if (sourcetime == targettime)
      {
        for (info.ResetLevel(); info.NextLevel(); ++level)
        {
          unsigned long xcounter = (this->xinverted() ? xsize() - 1 : 0);  // Current x-coordinate

          // Calculating every point by multiplication is slow so saving the starting point of
          // current row Further improvement when both axises are non-inverted does not improve
          // performance
          unsigned long ystart = zstart + (this->yinverted() ? (ysize() - 1) * xsize() : 0);

          if (options.debug)
            std::cerr << "debug: starting copy loop, level=" << level << " xcounter=" << xcounter
                      << " ystart=" << ystart << std::endl;

          // Inner loop contains all of the x,y values on this level
          for (info.ResetLocation(); info.NextLocation();)
          {
            float value = vals.at(ystart + xcounter);
            if (!IsMissingValue(value, missingvalue))
            {
              value = scale * value + offset;
              info.FloatValue(value);
            }

            // Next row?
            if (xcounter == (xinverted() ? 0 : xsize() - 1))
            {
              // Yes, increase the y counter and reset x
              ystart += (yinverted() ? -xsize() : +xsize());
              xcounter = (xinverted() ? xsize() - 1 : 0);
            }
            else
            {
              // No, just increase x (or decrease if inverted )
              (this->xinverted() ? xcounter-- : xcounter++);
            }
          }

          // Next level start point
          zstart += xsize() * ysize();

          if (options.debug)
            std::cerr << "debug: after copy loop, level=" << level << " xcounter=" << xcounter
                      << " ystart=" << ystart << std::endl;
        }
        sourcetimeindex++;
      }
      else if (options.debug)
        std::cerr << "debug: sourcetime and targettime mismatch, advancing to next targettimeindex"
                  << std::endl;
    }
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Copy speed/direction variable data into querydata
 */
// ----------------------------------------------------------------------

void nctools::NcFileExtended::copy_values(NFmiFastQueryInfo &info,
                                 const ParamInfo &pinfo,
                                 const nctools::Options *options)
{
  try
  {
    const float pi = 3.14159265358979326f;

    const NcVar xvar = find_variable(pinfo.x_component);
    const NcVar yvar = find_variable(pinfo.y_component);

    if (xvar.isNull()|| yvar.isNull())
      return;

    float xmissingvalue = get_missingvalue(xvar);
    float xscale = get_scale(xvar);
    float xoffset = get_offset(xvar);

    float ymissingvalue = get_missingvalue(yvar);
    float yscale = get_scale(yvar);
    float yoffset = get_offset(yvar);

    // NetCDF data ordering: time, level, y, x
    int sourcetimeindex = 0;
    int targettimeindex = 0;
    for (info.ResetTime(); info.NextTime(); ++targettimeindex)
    {
      // Only copy to correct time index
      NFmiTime targettime = info.Time();

      auto tmp_tlist = timeList();
      const NFmiTime *sourcetimeptr = tmp_tlist.Time(sourcetimeindex);

      if (options->debug)
        std::cerr << "debug: targettimeindex=" << targettimeindex << " targettime=" << targettime
                  << " sourcetimeindex= " << sourcetimeindex << " sourcetimeptr=" << sourcetimeptr
                  << std::endl;

      // Skip to next targettimeindex or drop out(to next file possibly) if source does not have
      // this index at all (we are at end of source times?)
      if (sourcetimeptr == nullptr)
      {
        if (options->debug)
          std::cerr << "debug: source has no more times, skipping rest of target indexes"
                    << std::endl;
        break;  // Pointless to go through the rest of list, there are none
      }

      NFmiTime sourcetime = *sourcetimeptr;
      if (options->debug)
        std::cerr << "debug: sourcetime=" << sourcetime << std::endl;

      if (sourcetime == targettime)
      {
        // must delete
        const std::vector<float> xvals = nctools::get_values<float>(xvar);
        const std::vector<float> yvals = nctools::get_values<float>(yvar);
        if (options != nullptr && options->debug)
        {
          std::cerr << (std::string) "debug: x-component has " + std::to_string(xvals.size()) +
                           " elements\n";
          std::cerr << (std::string) "debug: y-component has " + std::to_string(yvals.size()) +
                           " elements\n";
        }
        long counter = 0;
        for (info.ResetLevel(); info.NextLevel();)
          for (info.ResetLocation(); info.NextLocation();)
          {
            if (xinverted() || yinverted())
              throw Fmi::Exception(BCP, std::string("Inverted axises not implemented here yet"));
            float x = xvals.at(counter);
            float y = yvals.at(counter);
            if (x != xmissingvalue && y != ymissingvalue)
            {
              x = xscale * x + xoffset;
              y = yscale * y + yoffset;

              // We assume everything is in m/s here and all is fine

              if (pinfo.isspeed)
                info.FloatValue(sqrt(x * x + y * y));
              else
                info.FloatValue(180 * atan2(x, y) / pi);
            }
            ++counter;
          }
        if (options != nullptr && options->debug)
          std::cerr << "debug: counter went through " + std::to_string(counter) + " elements\n";

        sourcetimeindex++;
      }
      else if (options->debug)
        std::cerr << "debug: sourcetime and targettime mismatch, advancing to next targettimeindex"
                  << std::endl;
    }
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

nctools::NcFileExtended::NcFileExtended(std::string path,
                               long timeshift,
                               FileMode fm,
                               size_t *bufrsizeptr,
                               size_t initialsize,
                               FileFormat ff)
    : NcFile(path, fm)
    , path(path)
    , timeshift(timeshift)
{
  // FIXME: remove unneeded parameters
  (void)bufrsizeptr;
  (void)initialsize;
}

std::string nctools::NcFileExtended::grid_mapping()
{
  try
  {
    if (projectionName != nullptr)
      return *projectionName;  // Do not rescan projection unnecessarily

    std::string projection_var_name;

    std::multimap<std::string, NcVar> vars = getVars();
    for (const auto& item : vars)
    {
      const NcVar& var = item.second;
      if (var.isNull())
        continue;

      const NcVarAtt att = ncvar_get_attr(var, "grid_mapping", true);
      if (att.isNull())
        continue;

      projection_var_name = nctools::get_att_string_value(att);
      break;
    }

    if (!projection_var_name.empty())
    {
      for (const auto& item : vars)
      {
        const NcVar& var = item.second;
        if (var.isNull())
          continue;

        if (var.getName() == projection_var_name)
        {
          const NcVarAtt name_att = ncvar_get_attr(var, "grid_mapping_name", false);
          if (name_att.isNull())
            projectionName = std::make_shared<std::string>(get_att_string_value(name_att));

          const NcVarAtt lon_att = ncvar_get_attr(var, "longitude_of_projection_origin", false);
          if (lon_att.isNull())
            longitudeOfProjectionOrigin = nctools::get_att_value<double>(lon_att, 0);
          const NcVarAtt lat_att = ncvar_get_attr(var, "latitude_of_projection_origin", false);
          if (lat_att.isNull())
            latitudeOfProjectionOrigin = nctools::get_att_value<double>(lat_att, 0);
          break;
        }
      }
    }

    if (projectionName == nullptr)
      projectionName = std::make_shared<std::string>(LATITUDE_LONGITUDE);

    return *projectionName;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Test if the given parameter name is a dimension instead of a regular variable
 */
// ----------------------------------------------------------------------

bool nctools::NcFileExtended::is_dim(const std::string &name) const
{
  try
  {
    auto lower_name = boost::algorithm::to_lower_copy(name);
    const std::multimap<std::string, NcDim> dims = getDims();
    for (const auto& item : dims)
    {
      std::string dimname = item.first;
      boost::algorithm::to_lower(dimname);

      if (lower_name == dimname)
        return true;
    }

    return false;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Test if the variable matches the requested axes
 */
// ----------------------------------------------------------------------

bool nctools::NcFileExtended::axis_match(const NcVar& var) const
{
  try
  {
    if (var.isNull())
      return false;

    // Number of dimensions the parameter must have
    int wanted_dims = 0;
    if (!x.isNull())
      ++wanted_dims;
    if (!y.isNull())
      ++wanted_dims;
    if (!z.isNull())
      ++wanted_dims;
    if (!t.isNull())
      ++wanted_dims;

    if (var.getDimCount() != wanted_dims)
      return false;

    int ok_count = 0;
    for (int i = 0; i < var.getDimCount(); i++)
    {
      const NcDim dim = var.getDim(i);
      if (dim.isNull())
        return false;
      std::string name = dim.getName();

      bool ok = (!x.isNull() && x.getName() == name)
             || (!y.isNull() && y.getName() == name)
             || (!z.isNull() && z.getName() == name)
             || (!t.isNull() && t.getName() == name);
      if (ok)
        ++ok_count;
    }

    return (ok_count == wanted_dims);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Find variable for the desired axis
 */
// ----------------------------------------------------------------------

NcVar nctools::NcFileExtended::axis(const std::set<std::string> &axisnames)
{
  if (options.debug)
  {
    std::cerr << "Allowed axes:";
    for (const auto &n : axisnames)
      std::cerr << " " << n;
    std::cerr << "\n";
  }

  try
  {
    const std::multimap<std::string, NcDim> dims = getDims();
    for (const auto& item : dims)
    {
      const NcDim& dim = item.second;;
      std::string name = item.first;
      boost::algorithm::to_lower(name);

      if (options.debug)
        std::cerr << "\tTrying axis " << name << "\n";

      auto pos = axisnames.find(name);

      if (pos != axisnames.end())
        return this->getVar(dim.getName());
    }

    return NcVar();
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Init axis dimensions from suggested (optional) parameter names
 */
// ----------------------------------------------------------------------

void nctools::NcFileExtended::initAxis(const std::optional<std::string> &xname,
                                       const std::optional<std::string> &yname,
                                       const std::optional<std::string> &zname,
                                       const std::optional<std::string> &tname)
{
  try
  {
    if (!wrf)
    {
      if (xname)
        x = axis({boost::algorithm::to_lower_copy(*xname)});
      else
        x = axis({"lon", "longitude", "x", "xc"});

      if (yname)
        y = axis({boost::algorithm::to_lower_copy(*yname)});
      else
        y = axis({"lat", "latitude", "y", "yc"});

      if (zname)
        z = axis({boost::algorithm::to_lower_copy(*zname)});
      else
        z = axis({"lev", "level", "z", "zc"});

      if (tname)
        t = axis({boost::algorithm::to_lower_copy(*tname)});
      else
        t = axis({"time", "t"});

      if (x.isNull())
        throw Fmi::Exception(BCP, "X-axis not found");
      if (y.isNull())
        throw Fmi::Exception(BCP, "Y-axis not found");
      if (z.isNull() && zname && !zname->empty())
        throw Fmi::Exception(BCP, "Z-axis not found");
      if (t.isNull() && tname && !tname->empty())
        throw Fmi::Exception(BCP, "T-axis not found");
    }
    else
    {
    }
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

bool nctools::NcFileExtended::isStereographic()
{
  return (grid_mapping() == POLAR_STEREOGRAPHIC);
}

// ----------------------------------------------------------------------
/*!
 * Find dimension of given axis
 */
// ----------------------------------------------------------------------

unsigned long nctools::NcFileExtended::axis_size(const NcVar& axis)
{
  try
  {
    if (axis.isNull())
      throw Fmi::Exception(BCP, std::string("Dimensions for axis null cannot be retrieved"));
    std::string varname = axis.getName();
    std::string dimname = boost::algorithm::to_lower_copy(varname);
    return axis_size(dimname);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

unsigned long nctools::NcFileExtended::axis_size(const std::string &dimname) const
{
  try
  {
    const std::multimap<std::string, NcDim> dims = getDims();
    for (const auto& item : dims)
    {
      const NcDim& dim = item.second;
      std::string name = item.first;
      boost::algorithm::to_lower(name);
      if (name == dimname)
        return dim.getSize();
    }
    throw Fmi::Exception(BCP, "Could not find dimension " + dimname);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

unsigned long nctools::NcFileExtended::xsize()
{
  try
  {
    if (!wrf)
      return axis_size(x);

    if (!options.xdim)
      throw Fmi::Exception(BCP, "WRF X-axis not defined");
    return axis_size(*options.xdim);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

unsigned long nctools::NcFileExtended::ysize()
{
  try
  {
    if (!wrf)
      return axis_size(y);

    if (!options.ydim)
      throw Fmi::Exception(BCP, "WRF Y-axis not defined");
    return axis_size(*options.ydim);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

unsigned long nctools::NcFileExtended::zsize()
{
  try
  {
    if (!wrf)
      return (z.isNull() ? 1 : axis_size(z));
    if (!options.zdim)
      throw Fmi::Exception(BCP, "WRF Z-axis not defined");
    return axis_size(*options.zdim);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

unsigned long nctools::NcFileExtended::tsize()
{
  try
  {
    if (!wrf)
      return (t.isNull() ? 0 : axis_size(t));
    if (!options.tdim)
      throw Fmi::Exception(BCP, "WRF T-axis not defined");
    return axis_size(*options.tdim);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

/*
 * Get list of times in this NetCDF file
 */
NFmiTimeList nctools::NcFileExtended::timeList(std::string varName, std::string unitAttrName)
{
  try
  {
    if (this->timelist != nullptr)
      return *(this->timelist);

    std::shared_ptr<NFmiTimeList> tlist = std::make_shared<NFmiTimeList>();
    if (wrf)
    {
      const NcVar ncvar = find_variable("Times");
      if (!ncvar.isNull())
      {
        const std::vector<char> ncvals = nctools::get_values<char>(ncvar);
        // "YYYY-MM-DD_HH:MI:SS"
        std::string stamp;
        for (auto ch : ncvals)
        {
          if (ch == '_')
            ch = 'T';
          stamp += ch;
        }
        auto t = Fmi::TimeParser::parse(stamp);
        tlist->Add(new NFmiMetTime(nctools::tomettime(t)));
      }
      this->timelist = tlist;

      return *(this->timelist);
    }

    if (isStereographic())
    {
      const NcVar ncvar = getVar(varName);
      if (ncvar.isNull())
        throw Fmi::Exception(BCP, "Could not find variable " + varName);
      const NcVarAtt units_att = ncvar_get_attr(ncvar, unitAttrName.c_str(), false);
      if (units_att.isNull())
        throw Fmi::Exception(BCP, "Could not find attribute " + unitAttrName + " for variable " +
                                     varName);

      std::string unit_val_value = nctools::get_att_string_value(units_att);

      std::vector<std::string> tokens;
      boost::split(tokens, unit_val_value, boost::algorithm::is_any_of(" "));

      // convert unit to seconds: day == 86400, hour == 3600, ...
      unsigned long unit_secs(get_units_in_seconds(tokens[0]));
      std::string date_str(tokens[2]);
      if (date_str.find('-') != std::string::npos)
      {
        if (isdigit(date_str[5]) && !isdigit(date_str[6]))
          date_str.insert(5, "0");
        if (isdigit(date_str[8]) && !isdigit(date_str[9]))
          date_str.insert(8, "0");
      }

      Fmi::DateTime torigin = Fmi::TimeParser::parse(date_str);

      const std::vector<long> ncvals = nctools::get_values<long>(ncvar);
      for (auto val : ncvals)
      {
        Fmi::DateTime timestep(torigin + Fmi::Seconds(val * unit_secs));
        tlist->Add(new NFmiMetTime(nctools::tomettime(timestep)));
      }
    }
    else
    {
      using Fmi::DateTime;
      Fmi::DateTime origintime;
      long timeunit;
      parse_time_units(&origintime, &timeunit);

      if (t.isNull())
      {
        tlist->Add(new NFmiMetTime(origintime));  // use origintime for static data
      }
      else
      {
        const std::vector<long> values = nctools::get_values<long>(t);
        for (long timeoffset : values)
        {
          Fmi::DateTime validtime = origintime + Fmi::Minutes(timeshift);

          if (timeunit == 1)
            validtime += Fmi::Seconds(timeoffset);
          else if (timeunit == 60)
            validtime += Fmi::Minutes(timeoffset);
          else if (timeunit == 60 * 60)
            validtime += Fmi::Hours(timeoffset);
          else if (timeunit == 24 * 60 * 60)
            validtime += Fmi::Hours(24 * timeoffset);
          else
            validtime += Fmi::Seconds(timeoffset * timeunit);

          tlist->Add(new NFmiMetTime(nctools::tomettime(validtime)));
        }
      }
    }

    this->timelist = tlist;

    return *this->timelist;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

unsigned long nctools::get_units_in_seconds(std::string unit_str)
{
  try
  {
    if (unit_str == "day" || unit_str == "days" || unit_str == "d")
      return 86400;
    else if (unit_str == "hour" || unit_str == "hours" || unit_str == "h")
      return 3600;
    else if (unit_str == "minute" || unit_str == "minutes" || unit_str == "min" ||
             unit_str == "mins")
      return 60;
    else if (unit_str == "second" || unit_str == "seconds" || unit_str == "sec" ||
             unit_str == "secs" || unit_str == "s")
      return 1;
    else
    {
      throw Fmi::Exception(BCP, "Invalid time unit used: " + unit_str);
    }
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Parse unit information from time attributes
 */
// ----------------------------------------------------------------------

void nctools::NcFileExtended::parse_time_units(Fmi::DateTime *origintime, long *timeunit) const
{
  try
  {  // If static data is extracted, --tdim '' has been used. We still need the origintime,
    // so we just assume "time" contains the required data as specified in COARDS etc
    NcVar tvar = t;
    if (tvar.isNull())
      tvar = this->getVar("time");

    if (tvar.isNull())
      throw Fmi::Exception(BCP, "Time axis unknown");

    const NcVarAtt att = ncvar_get_attr(tvar, "units", true);
    if (att.isNull())
      throw Fmi::Exception(BCP, "Time axis has no defined units");
    const NcType type = att.getType();
    if (type != NcType::nc_BYTE && type != NcType::nc_CHAR)
      throw Fmi::Exception(BCP, "Time axis units must be a string");

    // "units since date [time] [tz]"

    std::string units = nctools::get_att_string_value(att);

    std::vector<std::string> parts;
    boost::algorithm::split(parts, units, boost::algorithm::is_any_of(" "));

    if (parts.size() < 3 || parts.size() > 5)
      throw Fmi::Exception(BCP, "Invalid time units string: '" + units + "'");

    std::string unit = boost::algorithm::to_lower_copy(parts[0]);

    if (unit == "second" || unit == "seconds" || unit == "sec" || unit == "secs" || unit == "s")
      *timeunit = 1;
    else if (unit == "minute" || unit == "minutes" || unit == "min" || unit == "mins")
      *timeunit = 60;
    else if (unit == "hour" || unit == "hours" || unit == "hr" || unit == "h")
      *timeunit = 60 * 60;
    else if (unit == "day" || unit == "days" || unit == "d")
      *timeunit = 24 * 60 * 60;
    else
      throw Fmi::Exception(BCP, "Unknown unit in time axis: '" + unit + "'");

    if (boost::algorithm::to_lower_copy(parts[1]) != "since")
      throw Fmi::Exception(BCP, "Invalid time units string: '" + units + "'");

    std::string datestr = parts[2];
    std::string timestr = (parts.size() >= 4 ? parts[3] : "00:00:00");

    *origintime = Fmi::TimeParser::parse(datestr + " " + timestr);

    if (parts.size() == 5 && boost::iequals(parts[4], "UTC") == false)
      *origintime += Fmi::date_time::duration_from_string(parts[4]);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * \brief Construct NFmiMetTime from posix time
 */
// ----------------------------------------------------------------------

NFmiMetTime nctools::tomettime(const Fmi::DateTime &t)
{
  try
  {
    return NFmiMetTime(static_cast<short>(t.date().year()),
                       static_cast<short>(t.date().month()),
                       static_cast<short>(t.date().day()),
                       static_cast<short>(t.time_of_day().hours()),
                       static_cast<short>(t.time_of_day().minutes()),
                       static_cast<short>(t.time_of_day().seconds()),
                       1);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Find axis bounds
 */
// ----------------------------------------------------------------------

void nctools::NcFileExtended::find_axis_bounds(
    const NcVar&  var, int n, double &x1, double &x2, const char *name, bool &isdescending)
{
  try
  {
    if (var.isNull())
      return;

    const std::vector<double> values = nctools::get_values<double>(var);
    isdescending = false;  // Set to true if we detect decreasing instead of increasing values

    // Verify monotonous coordinates
    if (values.size() >= 2 && values.at(1) < values.at(0))
      isdescending = true;

    for (std::size_t i = 1; i < values.size(); i++)
    {
      if (isdescending == false && values.at(i) <= values.at(i-1))
        throw Fmi::Exception(BCP, std::string(name) + "-axis is not monotonously increasing");
      if (isdescending == true && values.at(i) >= values.at(i-1))
        throw Fmi::Exception(BCP, std::string(name) + "-axis is not monotonously decreasing");
    }

    // Min&max is now easy
    if (isdescending == false)
    {
      x1 = values.at(0);
      x2 = values.at(values.size() - 1);
    }
    else
    {
      x2 = values.at(0);
      x1 = values.at(values.size() - 1);
    }

    // Verify stepsize is even
    if (n <= 2)
      return;

    double step = (x2 - x1) / (n - 1);

    for (std::size_t i = 1; i < values.size(); i++)
    {
      double s;
      if (isdescending == false)
        s = values.at(i) - values.at(i - 1);
      else
        s = values.at(i - 1) - values.at(i);

      if (std::abs(s - step) > options.tolerance * step)
        throw Fmi::Exception(BCP,
                             std::string(name) + "-axis is not regular with tolerance " +
                                 std::to_string(options.tolerance));
    }
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

void nctools::NcFileExtended::find_lonlat_bounds(double &lon1, double &lat1, double &lon2, double &lat2)
{
  try
  {
    std::multimap<std::string, NcVar> vars = getVars();
    for (const auto& item : vars)
    {
      const NcVar& var = item.second;
      if (var.isNull())
        continue;
      const std::vector<double> values = nctools::get_values<double>(var);
      if (values.empty())
        continue;
      const NcVarAtt att = var.getAtt("standard_name");
      if (!att.isNull())
      {
        const std::string attributeStandardName = nctools::get_att_string_value(att);
        if (attributeStandardName == "longitude")
        {
          lon1 = *std::min_element(values.begin(), values.end());
          lon2 = *std::max_element(values.begin(), values.end());
        }
        else if (attributeStandardName == "latitude")
        {
          lat1 = *std::min_element(values.begin(), values.end());
          lat2 = *std::max_element(values.begin(), values.end());
        }
      }
      else
      {
        // Handle the case where standard_name attribute is not present
        if (var.getName() == "longitude")
        {
          lon1 = *std::min_element(values.begin(), values.end());
          lon2 = *std::max_element(values.begin(), values.end());
        }
        else if (var.getName() == "latitude")
        {
          lat1 = *std::min_element(values.begin(), values.end());
          lat2 = *std::max_element(values.begin(), values.end());
        }
      }
    }

    for (const auto& item : vars)
    {
      const NcVar&  ncvar = item.second;

      const NcVarAtt att = ncvar_get_attr(ncvar, "standard_name", true);
      if (!att.isNull())
      {
        std::string attributeStandardName(get_att_string_value(att));
        if (attributeStandardName == "longitude" || attributeStandardName == "latitude")
        {
          const std::vector<double> ncvals = nctools::get_values<double>(ncvar);
          if (attributeStandardName == "longitude")
          {
            lon1 = ncvals.front();
            lon2 = ncvals.back();
          }
          else
          {
            lat1 = ncvals.front();
            lat2 = ncvals.back();
          }
        }
      }
    }
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

void nctools::NcFileExtended::find_bounds()
{
  try
  {
    if (isStereographic())
    {
      find_lonlat_bounds(_xmin, _ymin, _xmax, _ymax);
    }
    else
    {
      find_axis_bounds(x, xsize(), _xmin, _xmax, "x", _xinverted);
      find_axis_bounds(y, ysize(), _ymin, _ymax, "y", _yinverted);
    }
    minmaxfound = true;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

bool nctools::NcFileExtended::xinverted()
{
  try
  {
    if (minmaxfound == false)
      find_bounds();
    return _xinverted;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}
bool nctools::NcFileExtended::yinverted()
{
  try
  {
    if (minmaxfound == false)
      find_bounds();
    return _yinverted;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

double nctools::NcFileExtended::xmin()
{
  try
  {
    if (minmaxfound == false)
      find_bounds();
    return _xmin;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}
double nctools::NcFileExtended::xmax()
{
  try
  {
    if (minmaxfound == false)
      find_bounds();
    return _xmax;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}
double nctools::NcFileExtended::ymin()
{
  try
  {
    if (minmaxfound == false)
      find_bounds();
    return _ymin;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}
double nctools::NcFileExtended::ymax()
{
  try
  {
    if (minmaxfound == false)
      find_bounds();
    return _ymax;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}
double nctools::NcFileExtended::zmin()
{
  try
  {
    if (minmaxfound == false)
      find_bounds();
    return _zmin;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}
double nctools::NcFileExtended::zmax()
{
  try
  {
    if (minmaxfound == false)
      find_bounds();
    return _zmax;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

/**
 * Handle axis units and scaling
 *
 *
 */
std::shared_ptr<std::string> nctools::NcFileExtended::get_axis_units(const NcVar& axis)
{
  try
  {  // String presentation of a particular units on an axis
    const NcVarAtt att = axis.getAtt("units");
    if (att.isNull())
      throw Fmi::Exception(
          BCP, axis.getName() + (std::string) "-axis has no units attribute");

    std::vector<char> units_chars = nctools::get_att_vector_value<char>(att);
    std::shared_ptr<std::string> units = std::make_shared<std::string>(units_chars.data(), units_chars.size());

    // Ref: CF conventions section 4.1 Latitude Coordinate
    /*	  if (units == "degrees_north") return;
              if (units == "degree_north") return;
              if (units == "degree_N") return;
              if (units == "degrees_N") return;
              if (units == "degreeN") return;
              if (units == "degreesN") return;
              if (units == "100  km") return;
              if (units == "m") return;
              if (units == "km") return;
    */
    //	  throw Fmi::Exception(BCP, "Y-axis has unknown units: " + units);
    return units;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

double nctools::NcFileExtended::get_axis_scale(const NcVar& axis,
                                      std::shared_ptr<std::string> *source_units,
                                      const std::string *target_units)
{
  try
  {
    // Get scaling multiplier for target
    // units, default target being meters
    *source_units = get_axis_units(axis);
    if (target_units != nullptr && target_units->compare("m") != 0)
      throw Fmi::Exception(BCP,
                           "Sorry: do not know how to convert " + **source_units + " to " +
                               *target_units + " on axis " + axis.getName());

    if (**source_units == "100  km")
      return 100 * 1000;
    if (**source_units == "m")
      return 1;
    if (**source_units == "km")
      return 1000;
    return 1;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

double nctools::NcFileExtended::x_scale()
{
  try
  {
    if (x_units == nullptr)
    {
      std::shared_ptr<std::string> tmp = nullptr;
      xscale = get_axis_scale(x, &tmp);
      x_units = tmp;
    }
    return xscale;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

double nctools::NcFileExtended::y_scale()
{
  try
  {
    if (y_units == nullptr)
    {
      std::shared_ptr<std::string> tmp = nullptr;
      yscale = get_axis_scale(y, &tmp);
      y_units = tmp;
    }
    return yscale;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

double nctools::NcFileExtended::z_scale()
{
  try
  {
    if (z_units == nullptr)
    {
      std::shared_ptr<std::string> tmp = nullptr;
      zscale = get_axis_scale(z, &tmp);
      z_units = tmp;
    }
    return zscale;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

/**
 * Miscellaneous
 */
bool nctools::NcFileExtended::joinable(NcFileExtended &ncfile, std::vector<std::string> *failreasons)
{
  try
  {
    bool ok = true;
    if (failreasons != nullptr)
      failreasons->clear();

    if (this->grid_mapping() != ncfile.grid_mapping())
    {
      ok = false;
      failreasons->push_back("projection is different");
    }
    if (this->xsize() != ncfile.xsize())
    {
      ok = false;
      failreasons->push_back("x-axis dimension is different");
    }
    if (this->ysize() != ncfile.ysize())
    {
      ok = false;
      failreasons->push_back("y-axis dimension is different");
    }
    if (this->zsize() != ncfile.zsize())
    {
      ok = false;
      failreasons->push_back("z-axis dimension is different");
    }
    if (this->longitudeOfProjectionOrigin != ncfile.longitudeOfProjectionOrigin)
    {
      ok = false;
      failreasons->push_back("origin(longitude) is different");
    }
    if (this->latitudeOfProjectionOrigin != ncfile.latitudeOfProjectionOrigin)
    {
      ok = false;
      failreasons->push_back("origin(latitude) is different");
    }
    if (this->xinverted() != ncfile.xinverted())
    {
      ok = false;
      failreasons->push_back("x-axis inversion is different");
    }
    if (this->yinverted() != ncfile.yinverted())
    {
      ok = false;
      failreasons->push_back("y-axis inversion is different");
    }
    if (this->x_scale() != ncfile.x_scale())
    {
      ok = false;
      failreasons->push_back("x-axis units are different");
    }
    if (this->y_scale() != ncfile.y_scale())
    {
      ok = false;
      failreasons->push_back("y-axis units are different");
    }
    if (this->isStereographic() != ncfile.isStereographic())
    {
      ok = false;
      failreasons->push_back("both files are not stereographic");
    }

    // TODO: Possibly z-axis units , stepping ? , whatever, time formats etc .
    return ok;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Validate the data conforms to CF
 */
// ----------------------------------------------------------------------

static int compare_versions(const std::string &v1, const std::string &v2)
{
  try
  {
    size_t v1pos = 0;
    size_t v2pos = 0;

    while (v1pos < v1.size())
    {
      size_t v1pe = v1.find('.', v1pos);
      size_t v2pe = v2.find('.', v2pos);
      // In the case that there are no subsequent dots, just point to end of string
      if (v1pe == std::string::npos)
        v1pe = v1.size();
      if (v2pe == std::string::npos)
        v2pe = v2.size();
      int v1part = 0;
      int v2part = 0;
      try
      {
        v1part = Fmi::stoi(v1.substr(v1pos, v1pe - v1pos));
      }
      catch (boost::bad_lexical_cast const &)
      {
        throw Fmi::Exception(BCP, "Unable to convert " + v1 + " to integer version parts");
      }
      try
      {
        v2part = Fmi::stoi(v2.substr(v2pos, v2pe - v2pos));
      }
      catch (boost::bad_lexical_cast const &)
      {
        throw Fmi::Exception(BCP, "Unable to convert " + v2 + " to integer version parts");
      }
      if (v1part != v2part)  // Version parts differ, no need to compare farther
        return v1part - v2part;
      v1pos = v1pe + 1;
      v2pos = v2pe + 1;
    }

    if (v2pos < v2.size())
      // If there is still something in v2, the versions match up to this point. It must be extra
      // parts after dot.
      return -1;
    // Nothing left on either one, they match fully
    return 0;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

void nctools::NcFileExtended::require_conventions(const std::string *reference)
{
  try
  {
    if (reference == nullptr || reference->empty())
      return;  // Always ok, if there is no required convention

    const NcGroupAtt att = getAtt("Conventions");
    if (att.isNull())
      throw Fmi::Exception(BCP, "The NetCDF file is missing the Conventions attribute");

    const netCDF::NcType type = att.getType();
    if (type != NcType::nc_CHAR)
      throw Fmi::Exception(BCP, "The Conventions attribute must be a string");

    // pernu 2018-02-07: We use to have sz parameter which limits the comparison like this:
    //  if (ref.substr(0, sz) != reference.substr(0, sz))
    // I don't get it: it just compares CF- !
    // Here we compare the actual version numbers and assume that larger is compliant with smaller
    // one
    std::vector<char> att_value = nctools::get_att_vector_value<char>(att);
    std::string ref(att_value.begin(), att_value.end());
    std::string cmp = *reference;
    std::string refsub = ref;

    // Accept COARDS as subset of all CF conventions
    if (ref == "COARDS")
      return;

    if (refsub.substr(0, 3) == "CF-")
      refsub = ref.substr(3);
    if (cmp.substr(0, 3) == "CF-")
      cmp = reference->substr(3);

    if (compare_versions(refsub, cmp) < 0)
      throw Fmi::Exception(BCP, "The file must conform to " + *reference + ", not to " + ref);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Print summary information on the dimensions
 */
// ----------------------------------------------------------------------

void nctools::NcFileExtended::printInfo() const
{
  try
  {  // Establish all dimension names and sizes
    std::map<std::string, std::size_t> dims_size;

    const std::multimap<std::string, NcDim> dims = this->getDims();
    for (const auto &dim : dims)
    {
      std::string name = dim.first;
      boost::algorithm::to_lower(name);
      dims_size[name] = dim.second.getSize();
    }

    // Establish all combinations of dimensions for the other parameters

    std::map<std::string, std::set<std::string>> grids_params;

    const std::multimap<std::string, NcVar> vars = this->getVars();
    for (const auto &var : vars)
    {
      const std::string& varname = var.first;
      const NcVar& ncvar = var.second;
      if (ncvar.isNull())
        continue;
      if (dims_size.find(varname) != dims_size.end())
        continue;  // Skip dim parameters

      std::string gridstr = "";
      const std::vector<NcDim> vDims = ncvar.getDims();
      for (const auto& dim : vDims)
      {
        std::string dimname = dim.getName();
        boost::algorithm::to_lower(dimname);
        if (!gridstr.empty())
          gridstr += ",";
        gridstr += dim.getName();
      }
      auto &names = grids_params[gridstr];  // generates std::set if not set yet
      names.insert(varname);
    }

    // Print the info

    std::cout << path << " information:\n";
    std::cout << "    Dimensions:\n";
    for (const auto &name_count : dims_size)
      std::cout << "\t" << name_count.first << '(' << name_count.second << ")\n";

    std::cout << "    Parameter dimensions:\n";
    for (const auto &grid_params : grids_params)
    {
      std::cout << "\t" << grid_params.first << " : "
                << boost::algorithm::join(grid_params.second, ",") << "\n";
    }
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}
