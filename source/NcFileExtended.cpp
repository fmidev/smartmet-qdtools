#include "NcFileExtended.h"
#include <boost/algorithm/string.hpp>
#include <boost/algorithm/string/split.hpp>
#include <macgyver/Exception.h>
#include <macgyver/StringConversion.h>
#include <macgyver/TimeParser.h>
#include <newbase/NFmiFastQueryInfo.h>
#include <iostream>
#include <memory>
#include <string>

namespace nctools
{
NcAtt *ncvar_get_attr(const NcVar *var, const char *name, bool silent)
{
  try
  {
    NcError netcdf_error_handling(NcError::silent_nonfatal);
    NcAtt *att = var->get_att(name);
    if (att == nullptr && !silent)
      std::cout << "NetCDF: attribute '" << name << "' not found" << std::endl;

    return att;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * \brief Extract NetCDF parameter name
 */
// ----------------------------------------------------------------------

std::string get_name(NcVar *var)
{
  try
  {
    NcError netcdf_error_handling(NcError::silent_nonfatal);
    NcAtt *att = ncvar_get_attr(var, "standard_name", true);
    if (att == 0)
      return var->name();

    if (att->type() != ncChar)
      throw std::runtime_error("The standard_name attribute must be a string for variable " +
                               std::string(var->name()));

    return att->values()->as_string(0);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Parse parameter id
 */
// ----------------------------------------------------------------------

ParamInfo parse_parameter(NcVar *var, const ParamConversions &paramconvs, bool useAutoGeneratedIds)
{
  try
  {
    if (var->num_dims() < 3 || var->num_dims() > 4)
      return ParamInfo();

    return parse_parameter(get_name(var), paramconvs, useAutoGeneratedIds);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * \brief Find variable with given name
 */
// ----------------------------------------------------------------------

NcVar *NcFileExtended::find_variable(const std::string &name)
{
  try
  {
    for (int i = 0; i < this->num_vars(); i++)
    {
      NcVar *var = this->get_var(i);
      if (var == nullptr)
        continue;
      if (get_name(var) == name)
        return var;
    }
    return nullptr;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * \brief Get the missing value
 */
// ----------------------------------------------------------------------

float NcFileExtended::get_missingvalue(NcVar *var) const
{
  try
  {
    if (!wrf)
    {
      NcAtt *att = ncvar_get_attr(var, "_FillValue", true);
      if (att != 0)
        return att->values()->as_float(0);
      // Fillvalue can be also fill_value
      att = ncvar_get_attr(var, "fill_value", false);
      if (att != 0)
        return att->values()->as_float(0);

      return std::numeric_limits<float>::quiet_NaN();
    }

    return std::numeric_limits<float>::quiet_NaN();
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * \brief Get the scale value
 */
// ----------------------------------------------------------------------

float get_scale(NcVar *var)
{
  try
  {
    NcAtt *att = ncvar_get_attr(var, "scale_factor", true);
    if (att != 0)
      return att->values()->as_float(0);
    else
      return 1.0f;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * \brief Get the offset value
 */
// ----------------------------------------------------------------------

float get_offset(NcVar *var)
{
  try
  {
    NcAtt *att = ncvar_get_attr(var, "add_offset", true);
    if (att != 0)
      return att->values()->as_float(0);
    else
      return 0.0f;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Report unit conversions if they are done
 */
// ----------------------------------------------------------------------

void report_units(NcVar *var,
                  const std::string &units,
                  const Options &options,
                  bool ignoreUnitChange)
{
  try
  {
    if (!options.verbose)
      return;

    if (units == "K")
    {
      if (ignoreUnitChange)
        std::cout << "Note: " << get_name(var) << " units convertion ignored from K to C"
                  << std::endl;
      else
        std::cout << "Note: " << get_name(var) << " units converted from K to C" << std::endl;
    }
    else if (units == "Pa")
    {
      if (ignoreUnitChange)
        std::cout << "Note: " << get_name(var) << " units convertion ignored from pa to hPa"
                  << std::endl;
      else
        std::cout << "Note: " << get_name(var) << " units converted from pa to hPa" << std::endl;
    }
    else if (units == "fraction")
    {
      if (ignoreUnitChange)
        std::cout << "Note: " << get_name(var)
                  << " units convertion ignored from fraction to percentage" << std::endl;
      else
        std::cout << "Note: " << get_name(var) << " units converted from fraction to percentage"
                  << std::endl;
    }
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

bool IsMissingValue(float value, float ncMissingValue)
{
  try
  {
    const float extraMissingValueLimit =
        9.99e034f;  // joskus datassa on outoja isoja (ja
                    // vaihtelevia) lukuja esim. vuoriston kohdalla,
    // jotka pit�� mielest�ni tulkita puuttuviksi (en tied� mit� muutakaan voi tehd�)
    if (value != ncMissingValue && value < extraMissingValueLimit)
      return false;
    else
      return true;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

bool is_name_in_list(const std::list<std::string> &nameList, const std::string name)
{
  try
  {
    if (!nameList.empty())
    {
      std::list<std::string>::const_iterator it = std::find(nameList.begin(), nameList.end(), name);
      if (it != nameList.end())
        return true;
    }
    return false;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Copy raw NetCDF data into querydata
 */
// ----------------------------------------------------------------------

void NcFileExtended::copy_values(const Options &options,
                                 NFmiFastQueryInfo &info,
                                 const ParamConversions &paramconvs,
                                 bool useAutoGeneratedIds)
{
  try
  {  // Note: We loop over variables the same way as in create_pdesc
    for (int i = 0; i < num_vars(); i++)
    {
      NcVar *var = get_var(i);
      if (var == nullptr)
        continue;

      if (!wrf)
      {
        if (!axis_match(var) && options.verbose)
          std::cerr << "warning: no matching axis for " << var->name() << "\n";
        continue;
      }

      ParamInfo pinfo = parse_parameter(nctools::get_name(var), paramconvs, useAutoGeneratedIds);
      if (pinfo.id == kFmiBadParameter)
        continue;

      if (info.Param(pinfo.id))
      {
        // Now we handle differently the two cases of a regular parameter
        // and one calculated from X- and Y-components

        if (pinfo.isregular)
          copy_values(options, var, info);
        else
          copy_values(info, pinfo, &options);
      }
    }
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Copy regular variable data into querydata
 */
// ----------------------------------------------------------------------

void NcFileExtended::copy_values(const Options &options, NcVar *var, NFmiFastQueryInfo &info)
{
  try
  {
    std::string name = var->name();

    if (options.debug)
      std::cerr << "\ndebug: starting copy for variable " << name << std::endl;

    std::string units = "";
    NcAtt *att = ncvar_get_attr(var, "units", true);
    if (att != 0)
      units = att->values()->as_string(0);

    // joskus metatiedot valehtelevat, tällöin ei saa muuttaa parametrin yksiköitä
    bool ignoreUnitChange = is_name_in_list(options.ignoreUnitChangeParams, name);

    report_units(var, units, options);

    float missingvalue = get_missingvalue(var);
    float scale = get_scale(var);
    float offset = get_offset(var);

    // Apply unit conversion outside the loop for speed
    if (!ignoreUnitChange)
    {
      if (units == "K")
        offset -= 273.15;
      else if (units == "Pa")
        scale *= 0.01;
      else if (units == "fraction")
        scale *= 100;
    }

    // NetCDF data ordering: time, level, rows from bottom row to top row, left-right order in row,
    // if none of the axises are inverted We have to calculate the actual position for inverted
    // axises. They will be non-inverted in the result data.
    int sourcetimeindex = 0;
    int targettimeindex = 0;

    NcValues *vals = var->values();

    unsigned long zstart = 0;

    for (info.ResetTime(); info.NextTime(); ++targettimeindex)
    {
      unsigned long level = 0;

      // Only copy to correct time index
      NFmiTime targettime = info.Time();

      auto tmp_tlist = timeList();
      const NFmiTime *sourcetimeptr = tmp_tlist.Time(sourcetimeindex);

      if (options.debug)
        std::cerr << "debug: targettimeindex=" << targettimeindex << " targettime=" << targettime
                  << " sourcetimeindex= " << sourcetimeindex << " sourcetimeptr=" << sourcetimeptr
                  << std::endl;

      // Skip to next targettimeindex or drop out(to next file possibly) if source does not have
      // this index at all (we are at end of source times?)
      if (sourcetimeptr == nullptr)
      {
        if (options.debug)
          std::cerr << "debug: source has no more times, skipping rest of target indexes"
                    << std::endl;
        break;  // Pointless to go through the rest of list, there are none
      }

      NFmiTime sourcetime = *sourcetimeptr;
      if (options.debug)
        std::cerr << "debug: sourcetime=" << sourcetime << std::endl;

      if (sourcetime == targettime)
      {
        for (info.ResetLevel(); info.NextLevel(); ++level)
        {
          unsigned long xcounter = (this->xinverted() ? xsize() - 1 : 0);  // Current x-coordinate

          // Calculating every point by multiplication is slow so saving the starting point of
          // current row Further improvement when both axises are non-inverted does not improve
          // performance
          unsigned long ystart = zstart + (this->yinverted() ? (ysize() - 1) * xsize() : 0);

          if (options.debug)
            std::cerr << "debug: starting copy loop, level=" << level << " xcounter=" << xcounter
                      << " ystart=" << ystart << std::endl;

          // Inner loop contains all of the x,y values on this level
          for (info.ResetLocation(); info.NextLocation();)
          {
            float value = vals->as_float(ystart + xcounter);
            if (!IsMissingValue(value, missingvalue))
            {
              value = scale * value + offset;
              info.FloatValue(value);
            }

            // Next row?
            if (xcounter == (xinverted() ? 0 : xsize() - 1))
            {
              // Yes, increase the y counter and reset x
              ystart += (yinverted() ? -xsize() : +xsize());
              xcounter = (xinverted() ? xsize() - 1 : 0);
            }
            else
            {
              // No, just increase x (or decrease if inverted )
              (this->xinverted() ? xcounter-- : xcounter++);
            }
          }

          // Next level start point
          zstart += xsize() * ysize();

          if (options.debug)
            std::cerr << "debug: after copy loop, level=" << level << " xcounter=" << xcounter
                      << " ystart=" << ystart << std::endl;
        }
        sourcetimeindex++;
      }
      else if (options.debug)
        std::cerr << "debug: sourcetime and targettime mismatch, advancing to next targettimeindex"
                  << std::endl;
    }
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Copy speed/direction variable data into querydata
 */
// ----------------------------------------------------------------------

void NcFileExtended::copy_values(NFmiFastQueryInfo &info,
                                 const ParamInfo &pinfo,
                                 const nctools::Options *options)
{
  try
  {
    const float pi = 3.14159265358979326f;

    NcVar *xvar = find_variable(pinfo.x_component);
    NcVar *yvar = find_variable(pinfo.y_component);

    if (xvar == nullptr || yvar == nullptr)
      return;

    float xmissingvalue = get_missingvalue(xvar);
    float xscale = get_scale(xvar);
    float xoffset = get_offset(xvar);

    float ymissingvalue = get_missingvalue(yvar);
    float yscale = get_scale(yvar);
    float yoffset = get_offset(yvar);

    // NetCDF data ordering: time, level, y, x
    int sourcetimeindex = 0;
    int targettimeindex = 0;
    for (info.ResetTime(); info.NextTime(); ++targettimeindex)
    {
      // Only copy to correct time index
      NFmiTime targettime = info.Time();

      auto tmp_tlist = timeList();
      const NFmiTime *sourcetimeptr = tmp_tlist.Time(sourcetimeindex);

      if (options->debug)
        std::cerr << "debug: targettimeindex=" << targettimeindex << " targettime=" << targettime
                  << " sourcetimeindex= " << sourcetimeindex << " sourcetimeptr=" << sourcetimeptr
                  << std::endl;

      // Skip to next targettimeindex or drop out(to next file possibly) if source does not have
      // this index at all (we are at end of source times?)
      if (sourcetimeptr == nullptr)
      {
        if (options->debug)
          std::cerr << "debug: source has no more times, skipping rest of target indexes"
                    << std::endl;
        break;  // Pointless to go through the rest of list, there are none
      }

      NFmiTime sourcetime = *sourcetimeptr;
      if (options->debug)
        std::cerr << "debug: sourcetime=" << sourcetime << std::endl;

      if (sourcetime == targettime)
      {
        // must delete
        NcValues *xvals = xvar->get_rec(sourcetimeindex);
        NcValues *yvals = yvar->get_rec(sourcetimeindex);
        if (options != nullptr && options->debug)
        {
          std::cerr << (std::string) "debug: x-component has " + std::to_string(xvals->num()) +
                           " elements\n";
          std::cerr << (std::string) "debug: y-component has " + std::to_string(yvals->num()) +
                           " elements\n";
        }
        long counter = 0;
        for (info.ResetLevel(); info.NextLevel();)
          for (info.ResetLocation(); info.NextLocation();)
          {
            if (xinverted() || yinverted())
              throw Fmi::Exception(BCP, std::string("Inverted axises not implemented here yet"));
            float x = xvals->as_float(counter);
            float y = yvals->as_float(counter);
            if (x != xmissingvalue && y != ymissingvalue)
            {
              x = xscale * x + xoffset;
              y = yscale * y + yoffset;

              // We assume everything is in m/s here and all is fine

              if (pinfo.isspeed)
                info.FloatValue(sqrt(x * x + y * y));
              else
                info.FloatValue(180 * atan2(x, y) / pi);
            }
            ++counter;
          }
        if (options != nullptr && options->debug)
          std::cerr << "debug: counter went through " + std::to_string(counter) + " elements\n";

        sourcetimeindex++;
        delete xvals;
        delete yvals;
      }
      else if (options->debug)
        std::cerr << "debug: sourcetime and targettime mismatch, advancing to next targettimeindex"
                  << std::endl;
    }
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

NcFileExtended::NcFileExtended(std::string path,
                               long timeshift,
                               FileMode fm,
                               size_t *bufrsizeptr,
                               size_t initialsize,
                               FileFormat ff)
    : NcFile(path.c_str(), fm, bufrsizeptr, initialsize, ff), path(path), timeshift(timeshift)
{
}

std::string NcFileExtended::grid_mapping()
{
  try
  {
    if (projectionName != nullptr)
      return *projectionName;  // Do not rescan projection unnecessarily

    std::string projection_var_name;

    for (int i = 0; i < num_vars(); i++)
    {
      NcVar *var = get_var(i);
      if (var == nullptr)
        continue;

      NcAtt *att = ncvar_get_attr(var, "grid_mapping", true);
      if (att == nullptr)
        continue;

      projection_var_name = att->values()->as_string(0);
      break;
    }

    if (!projection_var_name.empty())
    {
      for (int i = 0; i < num_vars(); i++)
      {
        NcVar *var = get_var(i);
        if (var == nullptr)
          continue;

        if (var->name() == projection_var_name)
        {
          NcAtt *name_att = ncvar_get_attr(var, "grid_mapping_name", false);
          if (name_att != 0)
            projectionName = std::make_shared<std::string>(name_att->values()->as_string(0));

          NcAtt *lon_att = ncvar_get_attr(var, "longitude_of_projection_origin", false);
          if (lon_att != 0)
            longitudeOfProjectionOrigin = lon_att->values()->as_double(0);
          NcAtt *lat_att = ncvar_get_attr(var, "latitude_of_projection_origin", false);
          if (lat_att != 0)
            latitudeOfProjectionOrigin = lat_att->values()->as_double(0);
          break;
        }
      }
    }

    if (projectionName == nullptr)
      projectionName = std::make_shared<std::string>(LATITUDE_LONGITUDE);

    return *projectionName;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Test if the given parameter name is a dimension instead of a regular variable
 */
// ----------------------------------------------------------------------

bool NcFileExtended::is_dim(const std::string &name) const
{
  try
  {
    auto lower_name = boost::algorithm::to_lower_copy(name);
    for (int i = 0; i < num_dims(); i++)
    {
      NcDim *dim = this->get_dim(i);
      std::string dimname = dim->name();
      boost::algorithm::to_lower(dimname);

      if (lower_name == dimname)
        return true;
    }

    return false;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Test if the variable matches the requested axes
 */
// ----------------------------------------------------------------------

bool NcFileExtended::axis_match(NcVar *var) const
{
  try
  {
    if (var == nullptr)
      return false;

    // Number of dimensions the parameter must have
    int wanted_dims = 0;
    if (x != nullptr)
      ++wanted_dims;
    if (y != nullptr)
      ++wanted_dims;
    if (z != nullptr)
      ++wanted_dims;
    if (t != nullptr)
      ++wanted_dims;

    if (var->num_dims() != wanted_dims)
      return false;

    int ok_count = 0;
    for (int i = 0; i < var->num_dims(); i++)
    {
      NcDim *dim = var->get_dim(i);
      if (dim == nullptr)
        return false;
      std::string name = dim->name();

      bool ok = (x != nullptr && x->name() == name) || (y != nullptr && y->name() == name) ||
                (z != nullptr && z->name() == name) || (t != nullptr && t->name() == name);
      if (ok)
        ++ok_count;
    }

    return (ok_count == wanted_dims);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Find variable for the desired axis
 */
// ----------------------------------------------------------------------

NcVar *NcFileExtended::axis(const std::set<std::string> &axisnames)
{
  if (options.debug)
  {
    std::cerr << "Allowed axes:";
    for (const auto &n : axisnames)
      std::cerr << " " << n;
    std::cerr << "\n";
  }

  try
  {
    for (int i = 0; i < num_dims(); i++)
    {
      NcDim *dim = this->get_dim(i);
      std::string name = dim->name();
      boost::algorithm::to_lower(name);

      if (options.debug)
        std::cerr << "\tTrying axis " << name << "\n";

      auto pos = axisnames.find(name);

      if (pos != axisnames.end())
        return this->get_var(dim->name());
    }

    return nullptr;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Init axis dimensions from suggested (optional) parameter names
 */
// ----------------------------------------------------------------------

void NcFileExtended::initAxis(const std::optional<std::string> &xname,
                              const std::optional<std::string> &yname,
                              const std::optional<std::string> &zname,
                              const std::optional<std::string> &tname)
{
  try
  {
    if (!wrf)
    {
      if (xname)
        x = axis({boost::algorithm::to_lower_copy(*xname)});
      else
        x = axis({"lon", "longitude", "x", "xc"});

      if (yname)
        y = axis({boost::algorithm::to_lower_copy(*yname)});
      else
        y = axis({"lat", "latitude", "y", "yc"});

      if (zname)
        z = axis({boost::algorithm::to_lower_copy(*zname)});
      else
        z = axis({"lev", "level", "z", "zc"});

      if (tname)
        t = axis({boost::algorithm::to_lower_copy(*tname)});
      else
        t = axis({"time", "t"});

      if (x == nullptr)
        throw Fmi::Exception(BCP, "X-axis not found");
      if (y == nullptr)
        throw Fmi::Exception(BCP, "Y-axis not found");
      if (z == nullptr && zname && !zname->empty())
        throw Fmi::Exception(BCP, "Z-axis not found");
      if (t == nullptr && tname && !tname->empty())
        throw Fmi::Exception(BCP, "T-axis not found");
    }
    else
    {
    }
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

bool NcFileExtended::isStereographic()
{
  return (grid_mapping() == POLAR_STEREOGRAPHIC);
}

// ----------------------------------------------------------------------
/*!
 * Find dimension of given axis
 */
// ----------------------------------------------------------------------

unsigned long NcFileExtended::axis_size(NcVar *axis)
{
  try
  {
    if (axis == nullptr)
      throw Fmi::Exception(BCP, std::string("Dimensions for axis null cannot be retrieved"));
    std::string varname = axis->name();
    std::string dimname = boost::algorithm::to_lower_copy(varname);
    return axis_size(dimname);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

unsigned long NcFileExtended::axis_size(const std::string &dimname) const
{
  try
  {
    for (int i = 0; i < num_dims(); i++)
    {
      NcDim *dim = get_dim(i);
      std::string name = dim->name();
      boost::algorithm::to_lower(name);
      if (name == dimname)
        return dim->size();
    }
    throw Fmi::Exception(BCP, "Could not find dimension " + dimname);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

unsigned long NcFileExtended::xsize()
{
  try
  {
    if (!wrf)
      return axis_size(x);

    if (!options.xdim)
      throw Fmi::Exception(BCP, "WRF X-axis not defined");
    return axis_size(*options.xdim);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

unsigned long NcFileExtended::ysize()
{
  try
  {
    if (!wrf)
      return axis_size(y);

    if (!options.ydim)
      throw Fmi::Exception(BCP, "WRF Y-axis not defined");
    return axis_size(*options.ydim);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

unsigned long NcFileExtended::zsize()
{
  try
  {
    if (!wrf)
      return (z == nullptr ? 1 : axis_size(z));
    if (!options.zdim)
      throw Fmi::Exception(BCP, "WRF Z-axis not defined");
    return axis_size(*options.zdim);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

unsigned long NcFileExtended::tsize()
{
  try
  {
    if (!wrf)
      return (t == nullptr ? 0 : axis_size(t));
    if (!options.tdim)
      throw Fmi::Exception(BCP, "WRF T-axis not defined");
    return axis_size(*options.tdim);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

/*
 * Get list of times in this NetCDF file
 */
NFmiTimeList NcFileExtended::timeList(std::string varName, std::string unitAttrName)
{
  try
  {
    if (this->timelist != nullptr)
      return *(this->timelist);

    std::shared_ptr<NFmiTimeList> tlist = std::make_shared<NFmiTimeList>();
    if (wrf)
    {
      NcVar *ncvar = find_variable("Times");
      if (ncvar != nullptr)
      {
        NcValues *ncvals = ncvar->values();  // "YYYY-MM-DD_HH:MI:SS"
        std::string stamp;
        for (int k = 0; k < ncvar->num_vals(); k++)
        {
          auto ch = static_cast<char>(ncvals->as_long(k));
          if (ch == '_')
            ch = 'T';
          stamp += ch;
        }
        auto t = Fmi::TimeParser::parse(stamp);
        tlist->Add(new NFmiMetTime(tomettime(t)));
      }
      this->timelist = tlist;

      return *(this->timelist);
    }

    if (isStereographic())
    {
      NcVar *ncvar = get_var(varName.c_str());
      NcAtt *units_att = ncvar_get_attr(ncvar, unitAttrName.c_str(), false);

      std::string unit_val_value(units_att->as_string(0));
      delete units_att;

      std::vector<std::string> tokens;
      boost::split(tokens, unit_val_value, boost::algorithm::is_any_of(" "));

      // convert unit to seconds: day == 86400, hour == 3600, ...
      unsigned long unit_secs(get_units_in_seconds(tokens[0]));
      std::string date_str(tokens[2]);
      if (date_str.find('-') != std::string::npos)
      {
        if (isdigit(date_str[5]) && !isdigit(date_str[6]))
          date_str.insert(5, "0");
        if (isdigit(date_str[8]) && !isdigit(date_str[9]))
          date_str.insert(8, "0");
      }

      Fmi::DateTime torigin = Fmi::TimeParser::parse(date_str);

      NcValues *ncvals = ncvar->values();
      for (int k = 0; k < ncvar->num_vals(); k++)
      {
        Fmi::DateTime timestep(torigin + Fmi::Seconds(ncvals->as_long(k) * unit_secs));
        tlist->Add(new NFmiMetTime(tomettime(timestep)));
      }
    }
    else
    {
      using Fmi::DateTime;
      Fmi::DateTime origintime;
      long timeunit;
      parse_time_units(&origintime, &timeunit);

      if (t == nullptr)
      {
        tlist->Add(new NFmiMetTime(origintime));  // use origintime for static data
      }
      else
      {
        NcValues *values = t->values();
        for (int i = 0; i < t->num_vals(); i++)
        {
          long timeoffset = values->as_int(i);

          Fmi::DateTime validtime = origintime + Fmi::Minutes(timeshift);

          if (timeunit == 1)
            validtime += Fmi::Seconds(timeoffset);
          else if (timeunit == 60)
            validtime += Fmi::Minutes(timeoffset);
          else if (timeunit == 60 * 60)
            validtime += Fmi::Hours(timeoffset);
          else if (timeunit == 24 * 60 * 60)
            validtime += Fmi::Hours(24 * timeoffset);
          else
            validtime += Fmi::Seconds(timeoffset * timeunit);

          tlist->Add(new NFmiMetTime(nctools::tomettime(validtime)));
        }
      }
    }

    this->timelist = tlist;

    return *this->timelist;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

unsigned long get_units_in_seconds(std::string unit_str)
{
  try
  {
    if (unit_str == "day" || unit_str == "days" || unit_str == "d")
      return 86400;
    else if (unit_str == "hour" || unit_str == "hours" || unit_str == "h")
      return 3600;
    else if (unit_str == "minute" || unit_str == "minutes" || unit_str == "min" ||
             unit_str == "mins")
      return 60;
    else if (unit_str == "second" || unit_str == "seconds" || unit_str == "sec" ||
             unit_str == "secs" || unit_str == "s")
      return 1;
    else
    {
      throw Fmi::Exception(BCP, "Invalid time unit used: " + unit_str);
    }
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Parse unit information from time attributes
 */
// ----------------------------------------------------------------------

void NcFileExtended::parse_time_units(Fmi::DateTime *origintime, long *timeunit) const
{
  try
  {  // If static data is extracted, --tdim '' has been used. We still need the origintime,
    // so we just assume "time" contains the required data as specified in COARDS etc
    NcVar *tvar = t;
    if (tvar == nullptr)
      tvar = this->get_var("time");

    if (!tvar)
      throw Fmi::Exception(BCP, "Time axis unknown");

    NcAtt *att = ncvar_get_attr(tvar, "units", true);
    if (att == 0)
      throw Fmi::Exception(BCP, "Time axis has no defined units");
    if (att->type() != ncChar)
      throw Fmi::Exception(BCP, "Time axis units must be a string");

    // "units since date [time] [tz]"

    std::string units = att->values()->as_string(0);

    std::vector<std::string> parts;
    boost::algorithm::split(parts, units, boost::algorithm::is_any_of(" "));

    if (parts.size() < 3 || parts.size() > 5)
      throw Fmi::Exception(BCP, "Invalid time units string: '" + units + "'");

    std::string unit = boost::algorithm::to_lower_copy(parts[0]);

    if (unit == "second" || unit == "seconds" || unit == "sec" || unit == "secs" || unit == "s")
      *timeunit = 1;
    else if (unit == "minute" || unit == "minutes" || unit == "min" || unit == "mins")
      *timeunit = 60;
    else if (unit == "hour" || unit == "hours" || unit == "hr" || unit == "h")
      *timeunit = 60 * 60;
    else if (unit == "day" || unit == "days" || unit == "d")
      *timeunit = 24 * 60 * 60;
    else
      throw Fmi::Exception(BCP, "Unknown unit in time axis: '" + unit + "'");

    if (boost::algorithm::to_lower_copy(parts[1]) != "since")
      throw Fmi::Exception(BCP, "Invalid time units string: '" + units + "'");

    std::string datestr = parts[2];
    std::string timestr = (parts.size() >= 4 ? parts[3] : "00:00:00");

    *origintime = Fmi::TimeParser::parse(datestr + " " + timestr);

    if (parts.size() == 5 && boost::iequals(parts[4], "UTC") == false)
      *origintime += Fmi::date_time::duration_from_string(parts[4]);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * \brief Construct NFmiMetTime from posix time
 */
// ----------------------------------------------------------------------

NFmiMetTime tomettime(const Fmi::DateTime &t)
{
  try
  {
    return NFmiMetTime(static_cast<short>(t.date().year()),
                       static_cast<short>(t.date().month()),
                       static_cast<short>(t.date().day()),
                       static_cast<short>(t.time_of_day().hours()),
                       static_cast<short>(t.time_of_day().minutes()),
                       static_cast<short>(t.time_of_day().seconds()),
                       1);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Find axis bounds
 */
// ----------------------------------------------------------------------

void NcFileExtended::find_axis_bounds(
    NcVar *var, int n, double &x1, double &x2, const char *name, bool &isdescending)
{
  try
  {
    if (var == nullptr)
      return;

    NcValues *values = var->values();
    isdescending = false;  // Set to true if we detect decreasing instead of increasing values

    // Verify monotonous coordinates
    if (var->num_vals() >= 2 && values->as_double(1) < values->as_double(0))
      isdescending = true;

    for (int i = 1; i < var->num_vals(); i++)
    {
      if (isdescending == false && values->as_double(i) <= values->as_double(i - 1))
        throw Fmi::Exception(BCP, std::string(name) + "-axis is not monotonously increasing");
      if (isdescending == true && values->as_double(i) >= values->as_double(i - 1))
        throw Fmi::Exception(BCP, std::string(name) + "-axis is not monotonously decreasing");
    }

    // Min&max is now easy
    if (isdescending == false)
    {
      x1 = values->as_double(0);
      x2 = values->as_double(var->num_vals() - 1);
    }
    else
    {
      x2 = values->as_double(0);
      x1 = values->as_double(var->num_vals() - 1);
    }

    // Verify stepsize is even
    if (n <= 2)
      return;

    double step = (x2 - x1) / (n - 1);

    for (int i = 1; i < var->num_vals(); i++)
    {
      double s;
      if (isdescending == false)
        s = values->as_double(i) - values->as_double(i - 1);
      else
        s = values->as_double(i - 1) - values->as_double(i);

      if (std::abs(s - step) > options.tolerance * step)
        throw Fmi::Exception(BCP,
                             std::string(name) + "-axis is not regular with tolerance " +
                                 std::to_string(options.tolerance));
    }
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

void NcFileExtended::find_lonlat_bounds(double &lon1, double &lat1, double &lon2, double &lat2)
{
  try
  {
    for (int i = 0; i < num_vars(); i++)
    {
      NcVar *ncvar = get_var(i);

      NcAtt *att = ncvar_get_attr(ncvar, "standard_name", true);
      if (att != 0)
      {
        std::string attributeStandardName(att->values()->as_string(0));
        if (attributeStandardName == "longitude" || attributeStandardName == "latitude")
        {
          NcValues *ncvals = ncvar->values();
          if (attributeStandardName == "longitude")
          {
            lon1 = ncvals->as_double(0);
            lon2 = ncvals->as_double(ncvar->num_vals() - 1);
          }
          else
          {
            lat1 = ncvals->as_double(0);
            lat2 = ncvals->as_double(ncvar->num_vals() - 1);
          }
          delete ncvals;
        }
      }
    }
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

void NcFileExtended::find_bounds()
{
  try
  {
    if (isStereographic())
    {
      find_lonlat_bounds(_xmin, _ymin, _xmax, _ymax);
    }
    else
    {
      find_axis_bounds(x, xsize(), _xmin, _xmax, "x", _xinverted);
      find_axis_bounds(y, ysize(), _ymin, _ymax, "y", _yinverted);
    }
    minmaxfound = true;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

bool NcFileExtended::xinverted()
{
  try
  {
    if (minmaxfound == false)
      find_bounds();
    return _xinverted;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}
bool NcFileExtended::yinverted()
{
  try
  {
    if (minmaxfound == false)
      find_bounds();
    return _yinverted;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

double NcFileExtended::xmin()
{
  try
  {
    if (minmaxfound == false)
      find_bounds();
    return _xmin;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}
double NcFileExtended::xmax()
{
  try
  {
    if (minmaxfound == false)
      find_bounds();
    return _xmax;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}
double NcFileExtended::ymin()
{
  try
  {
    if (minmaxfound == false)
      find_bounds();
    return _ymin;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}
double NcFileExtended::ymax()
{
  try
  {
    if (minmaxfound == false)
      find_bounds();
    return _ymax;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}
double NcFileExtended::zmin()
{
  try
  {
    if (minmaxfound == false)
      find_bounds();
    return _zmin;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}
double NcFileExtended::zmax()
{
  try
  {
    if (minmaxfound == false)
      find_bounds();
    return _zmax;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

/**
 * Handle axis units and scaling
 *
 *
 */
std::shared_ptr<std::string> NcFileExtended::get_axis_units(NcVar *axis)
{
  try
  {  // String presentation of a particular units on an axis
    NcAtt *att = axis->get_att("units");
    if (att == 0)
      throw Fmi::Exception(
          BCP, (std::string)axis->name() + (std::string) "-axis has no units attribute");

    std::shared_ptr<std::string> units = std::make_shared<std::string>(att->values()->as_string(0));

    // Ref: CF conventions section 4.1 Latitude Coordinate
    /*	  if (units == "degrees_north") return;
              if (units == "degree_north") return;
              if (units == "degree_N") return;
              if (units == "degrees_N") return;
              if (units == "degreeN") return;
              if (units == "degreesN") return;
              if (units == "100  km") return;
              if (units == "m") return;
              if (units == "km") return;
    */
    //	  throw Fmi::Exception(BCP, "Y-axis has unknown units: " + units);
    return units;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

double NcFileExtended::get_axis_scale(NcVar *axis,
                                      std::shared_ptr<std::string> *source_units,
                                      const std::string *target_units)
{
  try
  {
    // Get scaling multiplier for target
    // units, default target being meters
    *source_units = get_axis_units(axis);
    if (target_units != nullptr && target_units->compare("m") != 0)
      throw Fmi::Exception(BCP,
                           "Sorry: do not know how to convert " + **source_units + " to " +
                               *target_units + " on axis " + axis->name());

    if (**source_units == "100  km")
      return 100 * 1000;
    if (**source_units == "m")
      return 1;
    if (**source_units == "km")
      return 1000;
    return 1;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

double NcFileExtended::x_scale()
{
  try
  {
    if (x_units == nullptr)
    {
      std::shared_ptr<std::string> tmp = nullptr;
      xscale = get_axis_scale(x, &tmp);
      x_units = tmp;
    }
    return xscale;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

double NcFileExtended::y_scale()
{
  try
  {
    if (y_units == nullptr)
    {
      std::shared_ptr<std::string> tmp = nullptr;
      yscale = get_axis_scale(y, &tmp);
      y_units = tmp;
    }
    return yscale;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

double NcFileExtended::z_scale()
{
  try
  {
    if (z_units == nullptr)
    {
      std::shared_ptr<std::string> tmp = nullptr;
      zscale = get_axis_scale(z, &tmp);
      z_units = tmp;
    }
    return zscale;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

/**
 * Miscellaneous
 */
bool NcFileExtended::joinable(NcFileExtended &ncfile, std::vector<std::string> *failreasons)
{
  try
  {
    bool ok = true;
    if (failreasons != nullptr)
      failreasons->clear();

    if (this->grid_mapping() != ncfile.grid_mapping())
    {
      ok = false;
      failreasons->push_back("projection is different");
    }
    if (this->xsize() != ncfile.xsize())
    {
      ok = false;
      failreasons->push_back("x-axis dimension is different");
    }
    if (this->ysize() != ncfile.ysize())
    {
      ok = false;
      failreasons->push_back("y-axis dimension is different");
    }
    if (this->zsize() != ncfile.zsize())
    {
      ok = false;
      failreasons->push_back("z-axis dimension is different");
    }
    if (this->longitudeOfProjectionOrigin != ncfile.longitudeOfProjectionOrigin)
    {
      ok = false;
      failreasons->push_back("origin(longitude) is different");
    }
    if (this->latitudeOfProjectionOrigin != ncfile.latitudeOfProjectionOrigin)
    {
      ok = false;
      failreasons->push_back("origin(latitude) is different");
    }
    if (this->xinverted() != ncfile.xinverted())
    {
      ok = false;
      failreasons->push_back("x-axis inversion is different");
    }
    if (this->yinverted() != ncfile.yinverted())
    {
      ok = false;
      failreasons->push_back("y-axis inversion is different");
    }
    if (this->x_scale() != ncfile.x_scale())
    {
      ok = false;
      failreasons->push_back("x-axis units are different");
    }
    if (this->y_scale() != ncfile.y_scale())
    {
      ok = false;
      failreasons->push_back("y-axis units are different");
    }
    if (this->isStereographic() != ncfile.isStereographic())
    {
      ok = false;
      failreasons->push_back("both files are not stereographic");
    }

    // TODO: Possibly z-axis units , stepping ? , whatever, time formats etc .
    return ok;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Validate the data conforms to CF
 */
// ----------------------------------------------------------------------

static int compare_versions(const std::string &v1, const std::string &v2)
{
  try
  {
    size_t v1pos = 0;
    size_t v2pos = 0;

    while (v1pos < v1.size())
    {
      size_t v1pe = v1.find('.', v1pos);
      size_t v2pe = v2.find('.', v2pos);
      // In the case that there are no subsequent dots, just point to end of string
      if (v1pe == std::string::npos)
        v1pe = v1.size();
      if (v2pe == std::string::npos)
        v2pe = v2.size();
      int v1part = 0;
      int v2part = 0;
      try
      {
        v1part = Fmi::stoi(v1.substr(v1pos, v1pe - v1pos));
      }
      catch (boost::bad_lexical_cast const &)
      {
        throw Fmi::Exception(BCP, "Unable to convert " + v1 + " to integer version parts");
      }
      try
      {
        v2part = Fmi::stoi(v2.substr(v2pos, v2pe - v2pos));
      }
      catch (boost::bad_lexical_cast const &)
      {
        throw Fmi::Exception(BCP, "Unable to convert " + v2 + " to integer version parts");
      }
      if (v1part != v2part)  // Version parts differ, no need to compare farther
        return v1part - v2part;
      v1pos = v1pe + 1;
      v2pos = v2pe + 1;
    }

    if (v2pos < v2.size())
      // If there is still something in v2, the versions match up to this point. It must be extra
      // parts after dot.
      return -1;
    // Nothing left on either one, they match fully
    return 0;
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

void NcFileExtended::require_conventions(const std::string *reference)
{
  try
  {
    if (reference == nullptr || reference->empty())
      return;  // Always ok, if there is no required convention

    NcAtt *att = get_att("Conventions");
    if (att == 0)
      throw Fmi::Exception(BCP, "The NetCDF file is missing the Conventions attribute");

    if (att->type() != ncChar)
      throw Fmi::Exception(BCP, "The Conventions attribute must be a string");

    // pernu 2018-02-07: We use to have sz parameter which limits the comparison like this:
    //  if (ref.substr(0, sz) != reference.substr(0, sz))
    // I don't get it: it just compares CF- !
    // Here we compare the actual version numbers and assume that larger is compliant with smaller
    // one
    std::string ref = att->values()->as_string(0);
    std::string cmp = *reference;
    std::string refsub = ref;

    // Accept COARDS as subset of all CF conventions
    if (ref == "COARDS")
      return;

    if (refsub.substr(0, 3) == "CF-")
      refsub = ref.substr(3);
    if (cmp.substr(0, 3) == "CF-")
      cmp = reference->substr(3);

    if (compare_versions(refsub, cmp) < 0)
      throw Fmi::Exception(BCP, "The file must conform to " + *reference + ", not to " + ref);
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

// ----------------------------------------------------------------------
/*!
 * Print summary information on the dimensions
 */
// ----------------------------------------------------------------------

void NcFileExtended::printInfo() const
{
  try
  {  // Establish all dimension names and sizes
    std::map<std::string, std::size_t> dims_size;

    for (int i = 0; i < this->num_dims(); i++)
    {
      NcDim *dim = this->get_dim(i);
      dims_size[dim->name()] = dim->size();
    }

    // Establish all combinations of dimensions for the other parameters

    std::map<std::string, std::set<std::string>> grids_params;

    for (int i = 0; i < this->num_vars(); i++)
    {
      NcVar *var = this->get_var(i);

      // Skip dim parameters
      if (dims_size.find(var->name()) != dims_size.end())
        continue;

      std::string varname = var->name();
      std::string gridstr = "";

      for (int j = 0; j < var->num_dims(); j++)
      {
        NcDim *dim = var->get_dim(j);
        if (!gridstr.empty())
          gridstr += ",";
        gridstr += dim->name();
      }
      auto &names = grids_params[gridstr];  // generates std::set if not set yet
      names.insert(varname);
    }

    // Print the info

    std::cout << path << " information:\n";
    std::cout << "    Dimensions:\n";
    for (const auto &name_count : dims_size)
      std::cout << "\t" << name_count.first << '(' << name_count.second << ")\n";

    std::cout << "    Parameter dimensions:\n";
    for (const auto &grid_params : grids_params)
    {
      std::cout << "\t" << grid_params.first << " : "
                << boost::algorithm::join(grid_params.second, ",") << "\n";
    }
  }
  catch (...)
  {
    throw Fmi::Exception::Trace(BCP, "Operation failed!");
  }
}

}  // namespace nctools
