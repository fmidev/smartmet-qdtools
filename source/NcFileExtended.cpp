#include "NcFileExtended.h"
#include <boost/algorithm/string.hpp>
#include <boost/algorithm/string/split.hpp>
#include <macgyver/Exception.h>
#include <macgyver/TimeParser.h>
#include <newbase/NFmiFastQueryInfo.h>
#include <iostream>
#include <memory>
#include <string>

namespace nctools
{
// ----------------------------------------------------------------------
/*!
 * \brief Extract NetCDF parameter name
 */
// ----------------------------------------------------------------------

std::string get_name(NcVar *var)
{
  NcAtt *att = var->get_att("standard_name");
  if (att == 0) return var->name();

  if (att->type() != ncChar)
    throw std::runtime_error("The standard_name attribute must be a string for variable " +
                             std::string(var->name()));

  return att->values()->as_string(0);
}

// ----------------------------------------------------------------------
/*!
 * Parse parameter id
 */
// ----------------------------------------------------------------------

ParamInfo parse_parameter(NcVar *var, const ParamConversions &paramconvs, bool useAutoGeneratedIds)
{
  if (var->num_dims() < 3 || var->num_dims() > 4) return ParamInfo();

  return parse_parameter(get_name(var), paramconvs, useAutoGeneratedIds);
}

// ----------------------------------------------------------------------
/*!
 * \brief Find variable with given name
 */
// ----------------------------------------------------------------------

NcVar *NcFileExtended::find_variable(const std::string &name)
{
  for (int i = 0; i < this->num_vars(); i++)
  {
    NcVar *var = this->get_var(i);
    if (var == nullptr) continue;
    if (get_name(var) == name) return var;
  }
  return nullptr;
}

// ----------------------------------------------------------------------
/*!
 * \brief Get the missing value
 */
// ----------------------------------------------------------------------

float get_missingvalue(NcVar *var)
{
  NcAtt *att = var->get_att("_FillValue");
  if (att != 0) return att->values()->as_float(0);
  // Fillvalue can be also fill_value
  att = var->get_att("fill_value");
  if (att != 0)
    return att->values()->as_float(0);
  else
    return std::numeric_limits<float>::quiet_NaN();
}

// ----------------------------------------------------------------------
/*!
 * \brief Get the scale value
 */
// ----------------------------------------------------------------------

float get_scale(NcVar *var)
{
  NcAtt *att = var->get_att("scale_factor");
  if (att != 0)
    return att->values()->as_float(0);
  else
    return 1.0f;
}

// ----------------------------------------------------------------------
/*!
 * \brief Get the offset value
 */
// ----------------------------------------------------------------------

float get_offset(NcVar *var)
{
  NcAtt *att = var->get_att("add_offset");
  if (att != 0)
    return att->values()->as_float(0);
  else
    return 0.0f;
}

// ----------------------------------------------------------------------
/*!
 * Report unit conversions if they are done
 */
// ----------------------------------------------------------------------

void report_units(NcVar *var,
                  const std::string &units,
                  const Options &options,
                  bool ignoreUnitChange)
{
  if (!options.verbose) return;

  if (units == "K")
  {
    if (ignoreUnitChange)
      std::cout << "Note: " << get_name(var) << " units convertion ignored from K to C"
                << std::endl;
    else
      std::cout << "Note: " << get_name(var) << " units converted from K to C" << std::endl;
  }
  else if (units == "Pa")
  {
    if (ignoreUnitChange)
      std::cout << "Note: " << get_name(var) << " units convertion ignored from pa to hPa"
                << std::endl;
    else
      std::cout << "Note: " << get_name(var) << " units converted from pa to hPa" << std::endl;
  }
  else if (units == "fraction")
  {
    if (ignoreUnitChange)
      std::cout << "Note: " << get_name(var)
                << " units convertion ignored from fraction to percentage" << std::endl;
    else
      std::cout << "Note: " << get_name(var) << " units converted from fraction to percentage"
                << std::endl;
  }
}

bool IsMissingValue(float value, float ncMissingValue)
{
  const float extraMissingValueLimit = 9.99e034f;  // joskus datassa on outoja isoja (ja
                                                   // vaihtelevia) lukuja esim. vuoriston kohdalla,
  // jotka pit�� mielest�ni tulkita puuttuviksi (en tied� mit� muutakaan voi tehd�)
  if (value != ncMissingValue && value < extraMissingValueLimit)
    return false;
  else
    return true;
}

bool is_name_in_list(const std::list<std::string> &nameList, const std::string name)
{
  if (!nameList.empty())
  {
    std::list<std::string>::const_iterator it = std::find(nameList.begin(), nameList.end(), name);
    if (it != nameList.end()) return true;
  }
  return false;
}

// ----------------------------------------------------------------------
/*!
 * Copy regular variable data into querydata
 */
// ----------------------------------------------------------------------

void NcFileExtended::copy_values(const Options &options, NcVar *var, NFmiFastQueryInfo &info)
{
  std::string name = var->name();

  std::string units = "";
  NcAtt *att = var->get_att("units");
  if (att != 0) units = att->values()->as_string(0);

  if (options.debug) std::cerr << "debug: starting copy for variable " << name << std::endl;

  // joskus metatiedot valehtelevat, t�ll�in ei saa muuttaa parametrin yksik�it�
  bool ignoreUnitChange = is_name_in_list(options.ignoreUnitChangeParams, name);

  report_units(var, units, options);

  float missingvalue = get_missingvalue(var);
  float scale = get_scale(var);
  float offset = get_offset(var);

  // Apply unit conversion outside the loop for speed
  if (!ignoreUnitChange)
  {
    if (units == "K")
      offset -= 273.15;
    else if (units == "Pa")
      scale *= 0.01;
    else if (units == "fraction")
      scale *= 100;
  }

  // NetCDF data ordering: time, level, rows from bottom row to top row, left-right order in row, if
  // none of the axises are inverted We have to calculate the actual position for inverted axises.
  // They will be non-inverted in the result data.
  int sourcetimeindex = 0;
  int targettimeindex = 0;

  NcValues *vals = var->values();

  unsigned long zstart = 0;

  for (info.ResetTime(); info.NextTime(); ++targettimeindex)
  {
    unsigned long level = 0;

    // Only copy to correct time index
    NFmiTime targettime = info.Time();

    auto tmp_tlist = timeList();
    const NFmiTime *sourcetimeptr = tmp_tlist.Time(sourcetimeindex);
    
    if (options.debug)
      std::cerr << "debug: targettimeindex=" << targettimeindex << " targettime=" << targettime
                << " sourcetimeindex= " << sourcetimeindex << " sourcetimeptr=" << sourcetimeptr
                << std::endl;

    // Skip to next targettimeindex or drop out(to next file possibly) if source does not have this
    // index at all (we are at end of source times?)
    if (sourcetimeptr == nullptr)
    {
      if (options.debug)
        std::cerr << "debug: source has no more times, skipping rest of target indexes"
                  << std::endl;
      break;  // Pointless to go through the rest of list, there are none
    }

    NFmiTime sourcetime = *sourcetimeptr;
    if (options.debug) std::cerr << "debug: sourcetime=" << sourcetime << std::endl;

    if (sourcetime == targettime)
    {
      for (info.ResetLevel(); info.NextLevel(); ++level)
      {
        unsigned long xcounter = (this->xinverted() ? xsize() - 1 : 0);  // Current x-coordinate

        // Calculating every point by multiplication is slow so saving the starting point of current
        // row Further improvement when both axises are non-inverted does not improve performance
        unsigned long ystart = zstart + (this->yinverted() ? (ysize() - 1) * xsize() : 0);

        if (options.debug)
          std::cerr << "debug: starting copy loop, level=" << level << " xcounter=" << xcounter
                    << " ystart=" << ystart << std::endl;

        // Inner loop contains all of the x,y values on this level
        for (info.ResetLocation(); info.NextLocation();)
        {
          float value = vals->as_float(ystart + xcounter);
          if (!IsMissingValue(value, missingvalue))
          {
            value = scale * value + offset;
            info.FloatValue(value);
          }

          // Next row?
          if (xcounter == (xinverted() ? 0 : xsize() - 1))
          {
            // Yes, increase the y counter and reset x
            ystart += (yinverted() ? -xsize() : +xsize());
            xcounter = (xinverted() ? xsize() - 1 : 0);
          }
          else
          {
            // No, just increase x (or decrease if inverted )
            (this->xinverted() ? xcounter-- : xcounter++);
          }
        }

        // Next level start point
        zstart += xsize() * ysize();

        if (options.debug)
          std::cerr << "debug: after copy loop, level=" << level << " xcounter=" << xcounter
                    << " ystart=" << ystart << std::endl;
      }
      sourcetimeindex++;
    }
    else if (options.debug)
      std::cerr << "debug: sourcetime and targettime mismatch, advancing to next targettimeindex"
                << std::endl;
  }
}

// ----------------------------------------------------------------------
/*!
 * Copy speed/direction variable data into querydata
 */
// ----------------------------------------------------------------------

void NcFileExtended::copy_values(NFmiFastQueryInfo &info,
                                 const ParamInfo &pinfo,
                                 const nctools::Options *options)
{
  const float pi = 3.14159265358979326f;

  NcVar *xvar = find_variable(pinfo.x_component);
  NcVar *yvar = find_variable(pinfo.y_component);

  if (xvar == nullptr || yvar == nullptr) return;

  float xmissingvalue = get_missingvalue(xvar);
  float xscale = get_scale(xvar);
  float xoffset = get_offset(xvar);

  float ymissingvalue = get_missingvalue(yvar);
  float yscale = get_scale(yvar);
  float yoffset = get_offset(yvar);

  // NetCDF data ordering: time, level, y, x
  int sourcetimeindex = 0;
  int targettimeindex = 0;
  for (info.ResetTime(); info.NextTime(); ++targettimeindex)
  {
    // Only copy to correct time index
    NFmiTime targettime = info.Time();

    auto tmp_tlist = timeList();
    const NFmiTime *sourcetimeptr = tmp_tlist.Time(sourcetimeindex);

    if (options->debug)
      std::cerr << "debug: targettimeindex=" << targettimeindex << " targettime=" << targettime
                << " sourcetimeindex= " << sourcetimeindex << " sourcetimeptr=" << sourcetimeptr
                << std::endl;

    // Skip to next targettimeindex or drop out(to next file possibly) if source does not have this
    // index at all (we are at end of source times?)
    if (sourcetimeptr == nullptr)
    {
      if (options->debug)
        std::cerr << "debug: source has no more times, skipping rest of target indexes"
                  << std::endl;
      break;  // Pointless to go through the rest of list, there are none
    }

    NFmiTime sourcetime = *sourcetimeptr;
    if (options->debug) std::cerr << "debug: sourcetime=" << sourcetime << std::endl;

    if (sourcetime == targettime)
    {
      // must delete
      NcValues *xvals = xvar->get_rec(sourcetimeindex);
      NcValues *yvals = yvar->get_rec(sourcetimeindex);
      if (options != nullptr && options->debug)
      {
        std::cerr << (std::string) "debug: x-component has " + std::to_string(xvals->num()) +
                         " elements\n";
        std::cerr << (std::string) "debug: y-component has " + std::to_string(yvals->num()) +
                         " elements\n";
      }
      long counter = 0;
      for (info.ResetLevel(); info.NextLevel();)
        for (info.ResetLocation(); info.NextLocation();)
        {
          if (xinverted() || yinverted())
            throw Fmi::Exception(
                BCP, std::string("Inverted axises not implemented here yet"));
          float x = xvals->as_float(counter);
          float y = yvals->as_float(counter);
          if (x != xmissingvalue && y != ymissingvalue)
          {
            x = xscale * x + xoffset;
            y = yscale * y + yoffset;

            // We assume everything is in m/s here and all is fine

            if (pinfo.isspeed)
              info.FloatValue(sqrt(x * x + y * y));
            else
              info.FloatValue(180 * atan2(x, y) / pi);
          }
          ++counter;
        }
      if (options != nullptr && options->debug)
        std::cerr << "debug: counter went through " + std::to_string(counter) + " elements\n";

      sourcetimeindex++;
      delete xvals;
      delete yvals;
    }
    else if (options->debug)
      std::cerr << "debug: sourcetime and targettime mismatch, advancing to next targettimeindex"
                << std::endl;
  }
}  // namespace nctools

// ----------------------------------------------------------------------
/*!
 * Copy raw NetCDF data into querydata
 */
// ----------------------------------------------------------------------

void NcFileExtended::copy_values(const Options &options,
                                 NFmiFastQueryInfo &info,
                                 const ParamConversions &paramconvs,
                                 bool useAutoGeneratedIds)
{
  // Note: We loop over variables the same way as in create_pdesc
  for (int i = 0; i < num_vars(); i++)
  {
    NcVar *var = get_var(i);
    if (var == nullptr) continue;

    if (!axis_match(var)) continue;

    ParamInfo pinfo = parse_parameter(nctools::get_name(var), paramconvs, useAutoGeneratedIds);
    if (pinfo.id == kFmiBadParameter) continue;

    if (info.Param(pinfo.id))
    {
      // Now we handle differently the two cases of a regular parameter
      // and one calculated from X- and Y-components

      if (pinfo.isregular)
        copy_values(options, var, info);
      else
        copy_values(info, pinfo, &options);
    }
  }
}

NcFileExtended::NcFileExtended(std::string path,
                               long timeshift,
                               FileMode fm,
                               size_t *bufrsizeptr,
                               size_t initialsize,
                               FileFormat ff)
    : NcFile(path.c_str(), fm, bufrsizeptr, initialsize, ff),
      path(path),
      longitudeOfProjectionOrigin(0),
      latitudeOfProjectionOrigin(0),
      tolerance(1e-3),
      projectionName(nullptr),
      x(nullptr),
      y(nullptr),
      z(nullptr),
      t(nullptr),
      minmaxfound(false),
      _xmin(0),
      _xmax(0),
      _ymin(0),
      _ymax(0),
      _zmin(0),
      _zmax(0),
      _xinverted(false),
      _yinverted(false),
      _zinverted(false),
      x_units(nullptr),
      y_units(nullptr),
      z_units(nullptr),
      xscale(0),
      yscale(0),
      zscale(0),
      timelist(nullptr)
{
  this->timeshift = timeshift;
}

std::string NcFileExtended::grid_mapping()
{
  if (projectionName != nullptr) return *projectionName;  // Do not rescan projection unnecessarily

  std::string projection_var_name;

  for (int i = 0; i < num_vars(); i++)
  {
    NcVar *var = get_var(i);
    if (var == nullptr) continue;

    NcAtt *att = var->get_att("grid_mapping");
    if (att == nullptr) continue;

    projection_var_name = att->values()->as_string(0);
    break;
  }

  if (!projection_var_name.empty())
  {
    for (int i = 0; i < num_vars(); i++)
    {
      NcVar *var = get_var(i);
      if (var == nullptr) continue;

      if (var->name() == projection_var_name)
      {
        NcAtt *name_att = var->get_att("grid_mapping_name");
        if (name_att != 0)
          projectionName = std::make_shared<std::string>(name_att->values()->as_string(0));

        NcAtt *lon_att = var->get_att("longitude_of_projection_origin");
        if (lon_att != 0) longitudeOfProjectionOrigin = lon_att->values()->as_double(0);
        NcAtt *lat_att = var->get_att("latitude_of_projection_origin");
        if (lat_att != 0) latitudeOfProjectionOrigin = lat_att->values()->as_double(0);
        break;
      }
    }
  }

  if (projectionName == nullptr) projectionName = std::make_shared<std::string>(LATITUDE_LONGITUDE);

  return *projectionName;
}

// ----------------------------------------------------------------------
/*!
 * Test if the given parameter name is a dimension instead of a regular variable
 */
// ----------------------------------------------------------------------

bool NcFileExtended::is_dim(const std::string &name) const
{
  auto lower_name = boost::algorithm::to_lower_copy(name);
  for (int i = 0; i < num_dims(); i++)
  {
    NcDim *dim = this->get_dim(i);
    std::string dimname = dim->name();
    boost::algorithm::to_lower(dimname);

    if (lower_name == dimname) return true;
  }

  return false;
}

// ----------------------------------------------------------------------
/*!
 * Test if the variable matches the requested axes
 */
// ----------------------------------------------------------------------

bool NcFileExtended::axis_match(NcVar *var) const
{
  if (var == nullptr) return false;

  // Number of dimensions the parameter must have
  int wanted_dims = 0;
  if (x != nullptr) ++wanted_dims;
  if (y != nullptr) ++wanted_dims;
  if (z != nullptr) ++wanted_dims;
  if (t != nullptr) ++wanted_dims;

  if (var->num_dims() != wanted_dims) return false;

  int ok_count = 0;
  for (int i = 0; i < var->num_dims(); i++)
  {
    NcDim *dim = var->get_dim(i);
    if (dim == nullptr) return false;
    std::string name = dim->name();

    bool ok = (x != nullptr && x->name() == name) || (y != nullptr && y->name() == name) ||
              (z != nullptr && z->name() == name) || (t != nullptr && t->name() == name);
    if (ok) ++ok_count;
  }

  return (ok_count == wanted_dims);
}

// ----------------------------------------------------------------------
/*!
 * Find variable for the desired axis
 */
// ----------------------------------------------------------------------

NcVar *NcFileExtended::axis(const std::set<std::string> &axisnames)
{
  for (int i = 0; i < num_dims(); i++)
  {
    NcDim *dim = this->get_dim(i);
    std::string name = dim->name();
    boost::algorithm::to_lower(name);

    auto pos = axisnames.find(name);

    if (pos != axisnames.end()) return this->get_var(dim->name());
  }

  return nullptr;
}

// ----------------------------------------------------------------------
/*!
 * Init axis dimensions from suggested (optional) parameter names
 */
// ----------------------------------------------------------------------

void NcFileExtended::initAxis(const boost::optional<std::string> &xname,
                              const boost::optional<std::string> &yname,
                              const boost::optional<std::string> &zname,
                              const boost::optional<std::string> &tname)
{
  if (xname)
    x = axis({boost::algorithm::to_lower_copy(*xname)});
  else
    x = axis({"lon", "longitude", "x", "xc"});

  if (yname)
    y = axis({boost::algorithm::to_lower_copy(*yname)});
  else
    y = axis({"lat", "latitude", "y", "yc"});

  if (zname)
    z = axis({boost::algorithm::to_lower_copy(*zname)});
  else
    z = axis({"lev", "level", "z", "zc"});

  if (tname)
    t = axis({boost::algorithm::to_lower_copy(*tname)});
  else
    t = axis({"time", "t"});

  if (x == nullptr) throw Fmi::Exception(BCP, "X-axis not found");
  if (y == nullptr) throw Fmi::Exception(BCP, "Y-axis not found");
  if (z == nullptr && zname && !zname->empty())
    throw Fmi::Exception(BCP, "Z-axis not found");
  if (t == nullptr && tname && !tname->empty())
    throw Fmi::Exception(BCP, "T-axis not found");
}

bool NcFileExtended::isStereographic() { return (grid_mapping() == POLAR_STEREOGRAPHIC); }

// ----------------------------------------------------------------------
/*!
 * Find dimension of given axis
 */
// ----------------------------------------------------------------------

unsigned long NcFileExtended::axis_size(NcVar *axis)
{
  if (axis == nullptr)
    throw Fmi::Exception(BCP,
                                     std::string("Dimensions for axis null cannot be retrieved"));
  std::string varname = axis->name();

  std::string dimname = boost::algorithm::to_lower_copy(varname);
  for (int i = 0; i < num_dims(); i++)
  {
    NcDim *dim = get_dim(i);
    std::string name = dim->name();
    boost::algorithm::to_lower(name);
    if (name == dimname) return dim->size();
  }
  throw Fmi::Exception(BCP, std::string("Could not find dimension of axis ") + varname);
}

unsigned long NcFileExtended::xsize() { return axis_size(x); }

unsigned long NcFileExtended::ysize() { return axis_size(y); }

unsigned long NcFileExtended::zsize() { return (z == nullptr ? 1 : axis_size(z)); }

unsigned long NcFileExtended::tsize()
{
  if (t == nullptr) return 0;
  return axis_size(t);
}

/*
 * Get list of times in this NetCDF file
 */
NFmiTimeList NcFileExtended::timeList(std::string varName, std::string unitAttrName)
{
  if (this->timelist != nullptr) return *(this->timelist);

  std::shared_ptr<NFmiTimeList> tlist = std::make_shared<NFmiTimeList>();
  if (isStereographic())
  {
    NcVar *ncvar = get_var(varName.c_str());
    NcAtt *units_att = ncvar->get_att(unitAttrName.c_str());

    std::string unit_val_value(units_att->as_string(0));
    delete units_att;

    std::vector<std::string> tokens;
    boost::split(tokens, unit_val_value, boost::algorithm::is_any_of(" "));

    // convert unit to seconds: day == 86400, hour == 3600, ...
    unsigned long unit_secs(get_units_in_seconds(tokens[0]));
    std::string date_str(tokens[2]);
    if (date_str.find('-') != std::string::npos)
    {
      if (isdigit(date_str[5]) && !isdigit(date_str[6])) date_str.insert(5, "0");
      if (isdigit(date_str[8]) && !isdigit(date_str[9])) date_str.insert(8, "0");
    }

    boost::posix_time::ptime torigin = Fmi::TimeParser::parse(date_str);

    NcValues *ncvals = ncvar->values();
    for (int k = 0; k < ncvar->num_vals(); k++)
    {
      boost::posix_time::ptime timestep(torigin +
                                        boost::posix_time::seconds(ncvals->as_long(k) * unit_secs));
      tlist->Add(new NFmiMetTime(tomettime(timestep)));
    }
  }
  else
  {
    using boost::posix_time::ptime;
    ptime origintime;
    long timeunit;
    parse_time_units(&origintime, &timeunit);

    if (t == nullptr)
    {
      tlist->Add(new NFmiMetTime(origintime));  // use origintime for static data
    }
    else
    {
      NcValues *values = t->values();
      for (int i = 0; i < t->num_vals(); i++)
      {
        long timeoffset = values->as_int(i);

        ptime validtime = origintime + boost::posix_time::minutes(timeshift);

        if (timeunit == 1)
          validtime += boost::posix_time::seconds(timeoffset);
        else if (timeunit == 60)
          validtime += boost::posix_time::minutes(timeoffset);
        else if (timeunit == 60 * 60)
          validtime += boost::posix_time::hours(timeoffset);
        else if (timeunit == 24 * 60 * 60)
          validtime += boost::posix_time::hours(24 * timeoffset);
        else
          validtime += boost::posix_time::seconds(timeoffset * timeunit);

        tlist->Add(new NFmiMetTime(nctools::tomettime(validtime)));
      }
    }
  }

  this->timelist = tlist;

  return *this->timelist;
}

unsigned long get_units_in_seconds(std::string unit_str)
{
  if (unit_str == "day" || unit_str == "days" || unit_str == "d")
    return 86400;
  else if (unit_str == "hour" || unit_str == "hours" || unit_str == "h")
    return 3600;
  else if (unit_str == "minute" || unit_str == "minutes" || unit_str == "min" || unit_str == "mins")
    return 60;
  else if (unit_str == "second" || unit_str == "seconds" || unit_str == "sec" ||
           unit_str == "secs" || unit_str == "s")
    return 1;
  else
  {
    throw Fmi::Exception(BCP, "Invalid time unit used: " + unit_str);
  }
}

// ----------------------------------------------------------------------
/*!
 * Parse unit information from time attributes
 */
// ----------------------------------------------------------------------

void NcFileExtended::parse_time_units(boost::posix_time::ptime *origintime, long *timeunit) const
{
  // If static data is extracted, --tdim '' has been used. We still need the origintime,
  // so we just assume "time" contains the required data as specified in COARDS etc
  NcVar *tvar = t;
  if (tvar == nullptr) tvar = this->get_var("time");

  if (!tvar) throw Fmi::Exception(BCP, "Time axis unknown");

  NcAtt *att = tvar->get_att("units");
  if (att == 0) throw Fmi::Exception(BCP, "Time axis has no defined units");
  if (att->type() != ncChar)
    throw Fmi::Exception(BCP, "Time axis units must be a string");

  // "units since date [time] [tz]"

  std::string units = att->values()->as_string(0);

  std::vector<std::string> parts;
  boost::algorithm::split(parts, units, boost::algorithm::is_any_of(" "));

  if (parts.size() < 3 || parts.size() > 5)
    throw Fmi::Exception(BCP, "Invalid time units string: '" + units + "'");

  std::string unit = boost::algorithm::to_lower_copy(parts[0]);

  if (unit == "second" || unit == "seconds" || unit == "sec" || unit == "secs" || unit == "s")
    *timeunit = 1;
  else if (unit == "minute" || unit == "minutes" || unit == "min" || unit == "mins")
    *timeunit = 60;
  else if (unit == "hour" || unit == "hours" || unit == "hr" || unit == "h")
    *timeunit = 60 * 60;
  else if (unit == "day" || unit == "days" || unit == "d")
    *timeunit = 24 * 60 * 60;
  else
    throw Fmi::Exception(BCP, "Unknown unit in time axis: '" + unit + "'");

  if (boost::algorithm::to_lower_copy(parts[1]) != "since")
    throw Fmi::Exception(BCP, "Invalid time units string: '" + units + "'");

  std::string datestr = parts[2];
  std::string timestr = (parts.size() >= 4 ? parts[3] : "00:00:00");

  *origintime = Fmi::TimeParser::parse_iso(datestr + "T" + timestr);

  if (parts.size() == 5 && boost::iequals(parts[4], "UTC") == false)
    *origintime += boost::posix_time::duration_from_string(parts[4]);
}

// ----------------------------------------------------------------------
/*!
 * \brief Construct NFmiMetTime from posix time
 */
// ----------------------------------------------------------------------

NFmiMetTime tomettime(const boost::posix_time::ptime &t)
{
  return NFmiMetTime(static_cast<short>(t.date().year()),
                     static_cast<short>(t.date().month()),
                     static_cast<short>(t.date().day()),
                     static_cast<short>(t.time_of_day().hours()),
                     static_cast<short>(t.time_of_day().minutes()),
                     static_cast<short>(t.time_of_day().seconds()),
                     1);
}

// ----------------------------------------------------------------------
/*!
 * Find axis bounds
 */
// ----------------------------------------------------------------------

void NcFileExtended::find_axis_bounds(
    NcVar *var, int n, double &x1, double &x2, const char *name, bool &isdescending)
{
  if (var == nullptr) return;

  NcValues *values = var->values();
  isdescending = false;  // Set to true if we detect decreasing instead of increasing values

  // Verify monotonous coordinates
  if (var->num_vals() >= 2 && values->as_double(1) < values->as_double(0)) isdescending = true;

  for (int i = 1; i < var->num_vals(); i++)
  {
    if (isdescending == false && values->as_double(i) <= values->as_double(i - 1))
      throw Fmi::Exception(BCP,
                                       std::string(name) + "-axis is not monotonously increasing");
    if (isdescending == true && values->as_double(i) >= values->as_double(i - 1))
      throw Fmi::Exception(BCP,
                                       std::string(name) + "-axis is not monotonously decreasing");
  }

  // Min&max is now easy
  if (isdescending == false)
  {
    x1 = values->as_double(0);
    x2 = values->as_double(var->num_vals() - 1);
  }
  else
  {
    x2 = values->as_double(0);
    x1 = values->as_double(var->num_vals() - 1);
  }

  // Verify stepsize is even
  if (n <= 2) return;

  double step = (x2 - x1) / (n - 1);

  for (int i = 1; i < var->num_vals(); i++)
  {
    double s;
    if (isdescending == false)
      s = values->as_double(i) - values->as_double(i - 1);
    else
      s = values->as_double(i - 1) - values->as_double(i);

    if (std::abs(s - step) > tolerance * step)
      throw Fmi::Exception(
          BCP,
          std::string(name) + "-axis is not regular with tolerance " + std::to_string(tolerance));
  }
}

void NcFileExtended::find_lonlat_bounds(double &lon1, double &lat1, double &lon2, double &lat2)
{
  for (int i = 0; i < num_vars(); i++)
  {
    NcVar *ncvar = get_var(i);

    NcAtt *att = ncvar->get_att("standard_name");
    if (att != 0)
    {
      std::string attributeStandardName(att->values()->as_string(0));
      if (attributeStandardName == "longitude" || attributeStandardName == "latitude")
      {
        NcValues *ncvals = ncvar->values();
        if (attributeStandardName == "longitude")
        {
          lon1 = ncvals->as_double(0);
          lon2 = ncvals->as_double(ncvar->num_vals() - 1);
        }
        else
        {
          lat1 = ncvals->as_double(0);
          lat2 = ncvals->as_double(ncvar->num_vals() - 1);
        }
        delete ncvals;
      }
    }
  }
}

void NcFileExtended::find_bounds()
{
  if (isStereographic())
  {
    find_lonlat_bounds(_xmin, _ymin, _xmax, _ymax);
  }
  else
  {
    find_axis_bounds(x, xsize(), _xmin, _xmax, "x", _xinverted);
    find_axis_bounds(y, ysize(), _ymin, _ymax, "y", _yinverted);
  }
  minmaxfound = true;
}

bool NcFileExtended::xinverted()
{
  if (minmaxfound == false) find_bounds();
  return _xinverted;
}
bool NcFileExtended::yinverted()
{
  if (minmaxfound == false) find_bounds();
  return _yinverted;
}

double NcFileExtended::xmin()
{
  if (minmaxfound == false) find_bounds();
  return _xmin;
}
double NcFileExtended::xmax()
{
  if (minmaxfound == false) find_bounds();
  return _xmax;
}
double NcFileExtended::ymin()
{
  if (minmaxfound == false) find_bounds();
  return _ymin;
}
double NcFileExtended::ymax()
{
  if (minmaxfound == false) find_bounds();
  return _ymax;
}
double NcFileExtended::zmin()
{
  if (minmaxfound == false) find_bounds();
  return _zmin;
}
double NcFileExtended::zmax()
{
  if (minmaxfound == false) find_bounds();
  return _zmax;
}

/**
 * Handle axis units and scaling
 *
 *
 */
std::shared_ptr<std::string> NcFileExtended::get_axis_units(NcVar *axis)
{
  // String presentation of a particular units on an axis
  NcAtt *att = axis->get_att("units");
  if (att == 0)
    throw Fmi::Exception(
        BCP, (std::string)axis->name() + (std::string) "-axis has no units attribute");

  std::shared_ptr<std::string> units = std::make_shared<std::string>(att->values()->as_string(0));

  // Ref: CF conventions section 4.1 Latitude Coordinate
  /*	  if (units == "degrees_north") return;
            if (units == "degree_north") return;
            if (units == "degree_N") return;
            if (units == "degrees_N") return;
            if (units == "degreeN") return;
            if (units == "degreesN") return;
            if (units == "100  km") return;
            if (units == "m") return;
            if (units == "km") return;
  */
  //	  throw Fmi::Exception(BCP, "Y-axis has unknown units: " + units);
  return units;
}

double NcFileExtended::get_axis_scale(NcVar *axis,
                                      std::shared_ptr<std::string> *source_units,
                                      const std::string *target_units)
{  // Get scaling multiplier for target
   // units, default target being meters
  *source_units = get_axis_units(axis);
  if (target_units != nullptr && target_units->compare("m") != 0)
    throw Fmi::Exception(BCP,
                                     "Sorry: do not know how to convert " + **source_units +
                                         " to " + *target_units + " on axis " + axis->name());

  if (**source_units == "100  km") return 100 * 1000;
  if (**source_units == "m") return 1;
  if (**source_units == "km") return 1000;
  return 1;
}

double NcFileExtended::x_scale()
{
  if (x_units == nullptr)
  {
    std::shared_ptr<std::string> tmp = nullptr;
    xscale = get_axis_scale(x, &tmp);
    x_units = tmp;
  }
  return xscale;
}

double NcFileExtended::y_scale()
{
  if (y_units == nullptr)
  {
    std::shared_ptr<std::string> tmp = nullptr;
    yscale = get_axis_scale(y, &tmp);
    y_units = tmp;
  }
  return yscale;
}

double NcFileExtended::z_scale()
{
  if (z_units == nullptr)
  {
    std::shared_ptr<std::string> tmp = nullptr;
    zscale = get_axis_scale(z, &tmp);
    z_units = tmp;
  }
  return zscale;
}

/**
 * Miscellaneous
 */
bool NcFileExtended::joinable(NcFileExtended &ncfile, std::vector<std::string> *failreasons)
{
  bool ok = true;
  if (failreasons != nullptr) failreasons->clear();

  if (this->grid_mapping() != ncfile.grid_mapping())
  {
    ok = false;
    failreasons->push_back("projection is different");
  }
  if (this->xsize() != ncfile.xsize())
  {
    ok = false;
    failreasons->push_back("x-axis dimension is different");
  }
  if (this->ysize() != ncfile.ysize())
  {
    ok = false;
    failreasons->push_back("y-axis dimension is different");
  }
  if (this->zsize() != ncfile.zsize())
  {
    ok = false;
    failreasons->push_back("z-axis dimension is different");
  }
  if (this->longitudeOfProjectionOrigin != ncfile.longitudeOfProjectionOrigin)
  {
    ok = false;
    failreasons->push_back("origin(longitude) is different");
  }
  if (this->latitudeOfProjectionOrigin != ncfile.latitudeOfProjectionOrigin)
  {
    ok = false;
    failreasons->push_back("origin(latitude) is different");
  }
  if (this->xinverted() != ncfile.xinverted())
  {
    ok = false;
    failreasons->push_back("x-axis inversion is different");
  }
  if (this->yinverted() != ncfile.yinverted())
  {
    ok = false;
    failreasons->push_back("y-axis inversion is different");
  }
  if (this->x_scale() != ncfile.x_scale())
  {
    ok = false;
    failreasons->push_back("x-axis units are different");
  }
  if (this->y_scale() != ncfile.y_scale())
  {
    ok = false;
    failreasons->push_back("y-axis units are different");
  }
  if (this->isStereographic() != ncfile.isStereographic())
  {
    ok = false;
    failreasons->push_back("both files are not stereographic");
  }

  // TODO: Possibly z-axis units , stepping ? , whatever, time formats etc .
  return ok;
}

// ----------------------------------------------------------------------
/*!
 * Validate the data conforms to CF
 */
// ----------------------------------------------------------------------

static int compare_versions(const std::string &v1, const std::string &v2)
{
  size_t v1pos = 0;
  size_t v2pos = 0;

  while (v1pos < v1.size())
  {
    size_t v1pe = v1.find('.', v1pos);
    size_t v2pe = v2.find('.', v2pos);
    // In the case that there are no subsequent dots, just point to end of string
    if (v1pe == std::string::npos) v1pe = v1.size();
    if (v2pe == std::string::npos) v2pe = v2.size();
    int v1part = 0;
    int v2part = 0;
    try
    {
      v1part = boost::lexical_cast<int>(v1.substr(v1pos, v1pe - v1pos));
    }
    catch (boost::bad_lexical_cast const &)
    {
      throw Fmi::Exception(BCP,
                                       "Unable to convert " + v1 + " to integer version parts");
    }
    try
    {
      v2part = boost::lexical_cast<int>(v2.substr(v2pos, v2pe - v2pos));
    }
    catch (boost::bad_lexical_cast const &)
    {
      throw Fmi::Exception(BCP,
                                       "Unable to convert " + v2 + " to integer version parts");
    }
    if (v1part != v2part)  // Version parts differ, no need to compare farther
      return v1part - v2part;
    v1pos = v1pe + 1;
    v2pos = v2pe + 1;
  }

  if (v2pos < v2.size())
    // If there is still something in v2, the versions match up to this point. It must be extra
    // parts after dot.
    return -1;
  // Nothing left on either one, they match fully
  return 0;
}

void NcFileExtended::require_conventions(const std::string *reference)
{
  if (reference == nullptr || reference->empty())
    return;  // Always ok, if there is no required convention

  NcAtt *att = get_att("Conventions");
  if (att == 0)
    throw Fmi::Exception(BCP, "The NetCDF file is missing the Conventions attribute");

  if (att->type() != ncChar)
    throw Fmi::Exception(BCP, "The Conventions attribute must be a string");

  // pernu 2018-02-07: We use to have sz parameter which limits the comparison like this:
  //  if (ref.substr(0, sz) != reference.substr(0, sz))
  // I don't get it: it just compares CF- !
  // Here we compare the actual version numbers and assume that larger is compliant with smaller one
  std::string ref = att->values()->as_string(0);
  std::string cmp = *reference;
  std::string refsub = ref;

  // Accept COARDS as subset of all CF conventions
  if (ref == "COARDS") return;

  if (refsub.substr(0, 3) == "CF-") refsub = ref.substr(3);
  if (cmp.substr(0, 3) == "CF-") cmp = reference->substr(3);

  if (compare_versions(refsub, cmp) < 0)
    throw Fmi::Exception(BCP,
                                     "The file must conform to " + *reference + ", not to " + ref);
}

// ----------------------------------------------------------------------
/*!
 * Print summary information on the dimensions
 */
// ----------------------------------------------------------------------

void NcFileExtended::printInfo() const
{
  // Establish all dimension names and sizes
  std::map<std::string, std::size_t> dims_size;

  for (int i = 0; i < this->num_dims(); i++)
  {
    NcDim *dim = this->get_dim(i);
    dims_size[dim->name()] = dim->size();
  }

  // Establish all combinations of dimensions for the other parameters

  std::map<std::string, std::set<std::string>> grids_params;

  for (int i = 0; i < this->num_vars(); i++)
  {
    NcVar *var = this->get_var(i);

    // Skip dim parameters
    if (dims_size.find(var->name()) != dims_size.end()) continue;

    std::string varname = var->name();
    std::string gridstr = "";

    for (int j = 0; j < var->num_dims(); j++)
    {
      NcDim *dim = var->get_dim(j);
      if (!gridstr.empty()) gridstr += ",";
      gridstr += dim->name();
    }
    auto &names = grids_params[gridstr];  // generates std::set if not set yet
    names.insert(varname);
  }

  // Print the info

  std::cout << path << " information:\n";
  std::cout << "    Dimensions:\n";
  for (const auto &name_count : dims_size)
    std::cout << "\t" << name_count.first << '(' << name_count.second << ")\n";

  std::cout << "    Parameter dimensions:\n";
  for (const auto &grid_params : grids_params)
  {
    std::cout << "\t" << grid_params.first << " : "
              << boost::algorithm::join(grid_params.second, ",") << "\n";
  }
}

}  // namespace nctools
