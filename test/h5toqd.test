#!/usr/bin/perl

$program = (-x "../h5toqd" ? "../h5toqd" : "h5toqd");

system('grep --quiet "#define WGS84 1" /usr/include/smartmet/newbase/NFmiGlobals.h');
$wgs84 = 1-($? >> 8);

$results = "results/hdf";
system("mkdir -p $results");

$errors = 0;

%usednames = ();

DoTest("daily precipitation","daily.sqd","daily.h5");
DoTest("dbz","dbz.sqd","dbz.h5");
DoTest("echo top","etop.sqd","etop.h5");
DoTest("max","max.sqd","max.h5");
DoTest("pac","pac.sqd","pac.h5");
DoTest("ppi","ppi.sqd","ppi.h5");
DoTest("vil","vil.sqd","vil.h5");
DoTest("rr3h","3h.sqd","3h.h5");
DoTest("cappi","cappi.sqd","cappi.h5");
DoTest("pvol","pvol.sqd","pvol.h5");

# Not Opera parameters:
# DoTest("zhail","zhail.sqd","zhail.h5");
# DoTest("lmr","lmr.sqd","lmr.h5");
# DoTest("ltb","ltb.sqd","ltb.h5");
# DoTest("smv","smv.sqd","smv.h5");
# DoTest("sri","sri.sqd","sri.h5");
# DoTest("srv","srv.sqd","srv.h5");
# DoTest("hshear","hshear.sqd","hshear.h5");
# DoTest("vshear","vshear.sqd","vshear.h5");
# DoTest("shear","shear.sqd","shear.h5");
# DoTest("shear2","shear2.sqd","shear2.h5");

print "$errors errors\n";
exit($errors);

# ----------------------------------------------------------------------
# Run a single test
# ----------------------------------------------------------------------

sub FindFile($$)
{
    my $dir = shift;
    my $name = shift;
    my $result;
    if (-e "$dir/$name.xz") {
        $result="$name.xz";
    } elsif (-e "$dir/$name.bz2") {
        $result="$name.bz2"
    } elsif (-e "$dir/$name.gz") {
        $result="$name.gz"
    } elsif (-e "$dir/$name.zstd") {
        $result="$name.zstd"
    } elsif (-e "$dir/$name") {
        $result=$name;
    }
    return $result;
}

sub Unpack($$)
{
    my $from = shift;
    my $to = shift;
    my $cmd;
    if ($from =~ m/\.xz$/) { $cmd = "xzcat"; }
    elsif ($from =~ m/\.bz2$/) { $cmd = "bzcat"; }
    elsif ($from =~ m/\.gz$/) { $cmd = "zcat"; }
    elsif ($from =~ m/\.zstd$/) { $cmd = "zstdcat"; }
    else { die "Archive type not recognized for $from"; }

    system("$cmd $from >$to") == 0 or die "Failed to unpack $from to $to: $!";
}

sub DoTest
{
    my($text,$name,$infile) = @_;

    if(exists($usednames{$name}))
    {
	print "Error: $name used more than once\n";
	exit(1);
    }
    $usednames{$name} = 1;

    my ($resultfile, $expected);

    if($wgs84) {
	$resultfile = FindFile($results, "$name.wgs84");
	$expected = "$name.wgs84";
    }

    if (not defined($resultfile)) {
	$resultfile = FindFile($results, $name);
        $expected = $name;
    }

    my @cleanup;
    my $input = FindFile("data/hdf", $infile);
    if ($input ne $infile) {
        push(@cleanup, "data/hdf/$infile");
        Unpack("data/hdf/$input", "data/hdf/$infile");
    }

    my($tmpfile) = "$expected.tmp";

    $cmd = "$program data/hdf/$infile $results/$tmpfile";

    # print "$cmd\n";
    # $output = `$cmd 2>/dev/null`;
    $output = `$cmd`;

    print padname($text);

    if(! -e "$results/$tmpfile")
    {
	++$errors;
	print " FAILED TO PRODUCE OUTPUT FILE\n";
    }
    elsif(! -e "$results/$resultfile")
    {
	++$errors;
        $resultfile=$expected;
	print " FAILED: TRUE RESULT MISSING ($results/$resultfile)\n";
	unlink("$results/$tmpfile");
    }
    else
    {
        my $cmd = "../qddifference $results/$resultfile $results/$tmpfile";
	my($difference) = `$cmd`;

	if(rindex($difference, "Error", 0) == 0)
	{
	    ++$errors;
	    print " FAILED! (grids not comparable with qddifference)\n";
	}
	else
	{
	    $difference =~ s/^\s+//;
	    $difference =~ s/\s+$//;

	    if($difference < 0.0001)
	    {
		if($difference <= 0)
		{ print " OK\n"; }
		else
		{ print " OK (diff <= $difference)\n"; }
		unlink("$results/$tmpfile");
	    }
	    else
	    {
		++$errors;
		print " FAILED! (maxdiff = $difference)\n";
		print "( $resultfile <> $tmpfile in $results/ )\n";
	    }
	}
    }

    foreach my $fn (@cleanup) {
        unlink($fn);
    }
}

# ----------------------------------------------------------------------
# Pad the given string to 70 characters with dots
# ----------------------------------------------------------------------

sub padname
{
    my($str) = @_[0];

    while(length($str) < 70)
    {
	$str .= ".";
    }
    return $str;
}

# ----------------------------------------------------------------------
